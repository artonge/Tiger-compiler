/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : Tiger.g
 *     -                            On : 2016-03-19 19:57:50
 *     -                for the parser : TigerParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "TigerParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pTigerParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pTigerParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pTigerParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pTigerParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   TigerParserTokenNames[56+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ADD",
        (pANTLR3_UINT8) "AND",
        (pANTLR3_UINT8) "ASSIGNE",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "COMP",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "ESC_CHAR",
        (pANTLR3_UINT8) "ESC_WS",
        (pANTLR3_UINT8) "FOR",
        (pANTLR3_UINT8) "FUNC",
        (pANTLR3_UINT8) "FUNC_CALL",
        (pANTLR3_UINT8) "ID",
        (pANTLR3_UINT8) "IF",
        (pANTLR3_UINT8) "INTEGER",
        (pANTLR3_UINT8) "LET",
        (pANTLR3_UINT8) "LETTER",
        (pANTLR3_UINT8) "MULT",
        (pANTLR3_UINT8) "OR",
        (pANTLR3_UINT8) "PARAM",
        (pANTLR3_UINT8) "PARAMS",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "VAR",
        (pANTLR3_UINT8) "WHILE",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "'&'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'/'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "':='",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'<='",
        (pANTLR3_UINT8) "'<>'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'>='",
        (pANTLR3_UINT8) "'break'",
        (pANTLR3_UINT8) "'do'",
        (pANTLR3_UINT8) "'else'",
        (pANTLR3_UINT8) "'end'",
        (pANTLR3_UINT8) "'for'",
        (pANTLR3_UINT8) "'function'",
        (pANTLR3_UINT8) "'if'",
        (pANTLR3_UINT8) "'in'",
        (pANTLR3_UINT8) "'let'",
        (pANTLR3_UINT8) "'nil'",
        (pANTLR3_UINT8) "'then'",
        (pANTLR3_UINT8) "'to'",
        (pANTLR3_UINT8) "'var'",
        (pANTLR3_UINT8) "'while'",
        (pANTLR3_UINT8) "'|'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 TigerParser_program_return
	program    (pTigerParser ctx);
static 
 TigerParser_instructions_return
	instructions    (pTigerParser ctx);
static 
 TigerParser_params_return
	params    (pTigerParser ctx);
static 
 TigerParser_param_return
	param    (pTigerParser ctx);
static 
 TigerParser_declararion_return
	declararion    (pTigerParser ctx);
static 
 TigerParser_instruction_return
	instruction    (pTigerParser ctx);
static 
 TigerParser_atom_return
	atom    (pTigerParser ctx);
static 
 TigerParser_value_return
	value    (pTigerParser ctx);
static 
 TigerParser_or_return
	or    (pTigerParser ctx);
static 
 TigerParser_and_return
	and    (pTigerParser ctx);
static 
 TigerParser_comparison_return
	comparison    (pTigerParser ctx);
static 
 TigerParser_addition_return
	addition    (pTigerParser ctx);
static 
 TigerParser_multiplication_return
	multiplication    (pTigerParser ctx);
static void	TigerParserFree(pTigerParser ctx);
static void     TigerParserReset (pTigerParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Tiger.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new TigerParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pTigerParser
TigerParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return TigerParserNewSSD(instream, NULL);
}

/** \brief Create a new TigerParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pTigerParser
TigerParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pTigerParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pTigerParser) ANTLR3_CALLOC(1, sizeof(TigerParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in TigerParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our TigerParser interface
     */
    ctx->program	= program;
    ctx->instructions	= instructions;
    ctx->params	= params;
    ctx->param	= param;
    ctx->declararion	= declararion;
    ctx->instruction	= instruction;
    ctx->atom	= atom;
    ctx->value	= value;
    ctx->or	= or;
    ctx->and	= and;
    ctx->comparison	= comparison;
    ctx->addition	= addition;
    ctx->multiplication	= multiplication;
    ctx->free			= TigerParserFree;
    ctx->reset			= TigerParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);

ctx->vectors	= antlr3VectorFactoryNew(0);
    /* Install the token table
     */
    PSRSTATE->tokenNames   = TigerParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
TigerParserReset (pTigerParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 TigerParserFree(pTigerParser ctx)
 {
    /* Free any scope memory
     */

ctx->vectors->close(ctx->vectors);
/* We created the adaptor so we must free it
 */
ADAPTOR->free(ADAPTOR);
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return TigerParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_program353  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_program353_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_program353	= { FOLLOW_instructions_in_program353_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instruction_in_instructions365  */
static	ANTLR3_BITWORD FOLLOW_instruction_in_instructions365_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instruction_in_instructions365	= { FOLLOW_instruction_in_instructions365_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_instructions371  */
static	ANTLR3_BITWORD FOLLOW_29_in_instructions371_bits[]	= { ANTLR3_UINT64_LIT(0x046A200001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_instructions371	= { FOLLOW_29_in_instructions371_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instruction_in_instructions375  */
static	ANTLR3_BITWORD FOLLOW_instruction_in_instructions375_bits[]	= { ANTLR3_UINT64_LIT(0x0000004040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_instruction_in_instructions375	= { FOLLOW_instruction_in_instructions375_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_instructions378  */
static	ANTLR3_BITWORD FOLLOW_38_in_instructions378_bits[]	= { ANTLR3_UINT64_LIT(0x046A200001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_instructions378	= { FOLLOW_38_in_instructions378_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instruction_in_instructions382  */
static	ANTLR3_BITWORD FOLLOW_instruction_in_instructions382_bits[]	= { ANTLR3_UINT64_LIT(0x0000004040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_instruction_in_instructions382	= { FOLLOW_instruction_in_instructions382_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_instructions386  */
static	ANTLR3_BITWORD FOLLOW_30_in_instructions386_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_instructions386	= { FOLLOW_30_in_instructions386_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_params440  */
static	ANTLR3_BITWORD FOLLOW_29_in_params440_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040008000) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_params440	= { FOLLOW_29_in_params440_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_in_params446  */
static	ANTLR3_BITWORD FOLLOW_param_in_params446_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_param_in_params446	= { FOLLOW_param_in_params446_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_params449  */
static	ANTLR3_BITWORD FOLLOW_33_in_params449_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_params449	= { FOLLOW_33_in_params449_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_in_params453  */
static	ANTLR3_BITWORD FOLLOW_param_in_params453_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_param_in_params453	= { FOLLOW_param_in_params453_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_params459  */
static	ANTLR3_BITWORD FOLLOW_30_in_params459_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_params459	= { FOLLOW_30_in_params459_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_param528  */
static	ANTLR3_BITWORD FOLLOW_ID_in_param528_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_param528	= { FOLLOW_ID_in_param528_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_param530  */
static	ANTLR3_BITWORD FOLLOW_36_in_param530_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_param530	= { FOLLOW_36_in_param530_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_param534  */
static	ANTLR3_BITWORD FOLLOW_ID_in_param534_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_param534	= { FOLLOW_ID_in_param534_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_57_in_declararion618  */
static	ANTLR3_BITWORD FOLLOW_57_in_declararion618_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_57_in_declararion618	= { FOLLOW_57_in_declararion618_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_declararion622  */
static	ANTLR3_BITWORD FOLLOW_ID_in_declararion622_bits[]	= { ANTLR3_UINT64_LIT(0x0000003000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_declararion622	= { FOLLOW_ID_in_declararion622_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_declararion625  */
static	ANTLR3_BITWORD FOLLOW_36_in_declararion625_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_declararion625	= { FOLLOW_36_in_declararion625_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_declararion629  */
static	ANTLR3_BITWORD FOLLOW_ID_in_declararion629_bits[]	= { ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_declararion629	= { FOLLOW_ID_in_declararion629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_declararion633  */
static	ANTLR3_BITWORD FOLLOW_37_in_declararion633_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_declararion633	= { FOLLOW_37_in_declararion633_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_declararion635  */
static	ANTLR3_BITWORD FOLLOW_value_in_declararion635_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_declararion635	= { FOLLOW_value_in_declararion635_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_50_in_declararion692  */
static	ANTLR3_BITWORD FOLLOW_50_in_declararion692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_50_in_declararion692	= { FOLLOW_50_in_declararion692_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_declararion696  */
static	ANTLR3_BITWORD FOLLOW_ID_in_declararion696_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_declararion696	= { FOLLOW_ID_in_declararion696_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_params_in_declararion698  */
static	ANTLR3_BITWORD FOLLOW_params_in_declararion698_bits[]	= { ANTLR3_UINT64_LIT(0x0000041000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_params_in_declararion698	= { FOLLOW_params_in_declararion698_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_declararion701  */
static	ANTLR3_BITWORD FOLLOW_36_in_declararion701_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_declararion701	= { FOLLOW_36_in_declararion701_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_declararion705  */
static	ANTLR3_BITWORD FOLLOW_ID_in_declararion705_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_declararion705	= { FOLLOW_ID_in_declararion705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_declararion709  */
static	ANTLR3_BITWORD FOLLOW_42_in_declararion709_bits[]	= { ANTLR3_UINT64_LIT(0x046A200021028000) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_declararion709	= { FOLLOW_42_in_declararion709_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_declararion711  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_declararion711_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_declararion711	= { FOLLOW_instructions_in_declararion711_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_53_in_instruction755  */
static	ANTLR3_BITWORD FOLLOW_53_in_instruction755_bits[]	= { ANTLR3_UINT64_LIT(0x0204000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_53_in_instruction755	= { FOLLOW_53_in_instruction755_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declararion_in_instruction757  */
static	ANTLR3_BITWORD FOLLOW_declararion_in_instruction757_bits[]	= { ANTLR3_UINT64_LIT(0x0214000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_declararion_in_instruction757	= { FOLLOW_declararion_in_instruction757_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_52_in_instruction760  */
static	ANTLR3_BITWORD FOLLOW_52_in_instruction760_bits[]	= { ANTLR3_UINT64_LIT(0x046B200021028000) };
static  ANTLR3_BITSET_LIST FOLLOW_52_in_instruction760	= { FOLLOW_52_in_instruction760_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction762  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction762_bits[]	= { ANTLR3_UINT64_LIT(0x046B200021028000) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction762	= { FOLLOW_instructions_in_instruction762_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_48_in_instruction765  */
static	ANTLR3_BITWORD FOLLOW_48_in_instruction765_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_48_in_instruction765	= { FOLLOW_48_in_instruction765_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_instruction816  */
static	ANTLR3_BITWORD FOLLOW_ID_in_instruction816_bits[]	= { ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_instruction816	= { FOLLOW_ID_in_instruction816_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_instruction818  */
static	ANTLR3_BITWORD FOLLOW_37_in_instruction818_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_instruction818	= { FOLLOW_37_in_instruction818_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_instruction820  */
static	ANTLR3_BITWORD FOLLOW_value_in_instruction820_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_instruction820	= { FOLLOW_value_in_instruction820_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_51_in_instruction899  */
static	ANTLR3_BITWORD FOLLOW_51_in_instruction899_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_51_in_instruction899	= { FOLLOW_51_in_instruction899_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_instruction901  */
static	ANTLR3_BITWORD FOLLOW_value_in_instruction901_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_instruction901	= { FOLLOW_value_in_instruction901_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_55_in_instruction903  */
static	ANTLR3_BITWORD FOLLOW_55_in_instruction903_bits[]	= { ANTLR3_UINT64_LIT(0x046A200021028000) };
static  ANTLR3_BITSET_LIST FOLLOW_55_in_instruction903	= { FOLLOW_55_in_instruction903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction907  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction907_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction907	= { FOLLOW_instructions_in_instruction907_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_47_in_instruction923  */
static	ANTLR3_BITWORD FOLLOW_47_in_instruction923_bits[]	= { ANTLR3_UINT64_LIT(0x046A200021028000) };
static  ANTLR3_BITSET_LIST FOLLOW_47_in_instruction923	= { FOLLOW_47_in_instruction923_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction927  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction927_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction927	= { FOLLOW_instructions_in_instruction927_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_58_in_instruction975  */
static	ANTLR3_BITWORD FOLLOW_58_in_instruction975_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_58_in_instruction975	= { FOLLOW_58_in_instruction975_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_instruction977  */
static	ANTLR3_BITWORD FOLLOW_value_in_instruction977_bits[]	= { ANTLR3_UINT64_LIT(0x0000400000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_instruction977	= { FOLLOW_value_in_instruction977_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_46_in_instruction979  */
static	ANTLR3_BITWORD FOLLOW_46_in_instruction979_bits[]	= { ANTLR3_UINT64_LIT(0x046A200021028000) };
static  ANTLR3_BITSET_LIST FOLLOW_46_in_instruction979	= { FOLLOW_46_in_instruction979_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction981  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction981_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction981	= { FOLLOW_instructions_in_instruction981_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_49_in_instruction1041  */
static	ANTLR3_BITWORD FOLLOW_49_in_instruction1041_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_49_in_instruction1041	= { FOLLOW_49_in_instruction1041_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_instruction1043  */
static	ANTLR3_BITWORD FOLLOW_ID_in_instruction1043_bits[]	= { ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_instruction1043	= { FOLLOW_ID_in_instruction1043_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_37_in_instruction1045  */
static	ANTLR3_BITWORD FOLLOW_37_in_instruction1045_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_37_in_instruction1045	= { FOLLOW_37_in_instruction1045_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_instruction1049  */
static	ANTLR3_BITWORD FOLLOW_value_in_instruction1049_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_instruction1049	= { FOLLOW_value_in_instruction1049_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_instruction1051  */
static	ANTLR3_BITWORD FOLLOW_56_in_instruction1051_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_56_in_instruction1051	= { FOLLOW_56_in_instruction1051_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_instruction1055  */
static	ANTLR3_BITWORD FOLLOW_value_in_instruction1055_bits[]	= { ANTLR3_UINT64_LIT(0x0000400000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_instruction1055	= { FOLLOW_value_in_instruction1055_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_46_in_instruction1057  */
static	ANTLR3_BITWORD FOLLOW_46_in_instruction1057_bits[]	= { ANTLR3_UINT64_LIT(0x046A200021028000) };
static  ANTLR3_BITSET_LIST FOLLOW_46_in_instruction1057	= { FOLLOW_46_in_instruction1057_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction1059  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction1059_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction1059	= { FOLLOW_instructions_in_instruction1059_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_45_in_instruction1102  */
static	ANTLR3_BITWORD FOLLOW_45_in_instruction1102_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_45_in_instruction1102	= { FOLLOW_45_in_instruction1102_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_value_in_instruction1109  */
static	ANTLR3_BITWORD FOLLOW_value_in_instruction1109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_value_in_instruction1109	= { FOLLOW_value_in_instruction1109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_atom1124  */
static	ANTLR3_BITWORD FOLLOW_ID_in_atom1124_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_atom1124	= { FOLLOW_ID_in_atom1124_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_atom1133  */
static	ANTLR3_BITWORD FOLLOW_ID_in_atom1133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_atom1133	= { FOLLOW_ID_in_atom1133_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_29_in_atom1135  */
static	ANTLR3_BITWORD FOLLOW_29_in_atom1135_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040008000) };
static  ANTLR3_BITSET_LIST FOLLOW_29_in_atom1135	= { FOLLOW_29_in_atom1135_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_atom1140  */
static	ANTLR3_BITWORD FOLLOW_ID_in_atom1140_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_atom1140	= { FOLLOW_ID_in_atom1140_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_atom1143  */
static	ANTLR3_BITWORD FOLLOW_33_in_atom1143_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_atom1143	= { FOLLOW_33_in_atom1143_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_atom1147  */
static	ANTLR3_BITWORD FOLLOW_ID_in_atom1147_bits[]	= { ANTLR3_UINT64_LIT(0x0000000240000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_atom1147	= { FOLLOW_ID_in_atom1147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_30_in_atom1153  */
static	ANTLR3_BITWORD FOLLOW_30_in_atom1153_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_30_in_atom1153	= { FOLLOW_30_in_atom1153_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_atom1155  */
static	ANTLR3_BITWORD FOLLOW_38_in_atom1155_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_atom1155	= { FOLLOW_38_in_atom1155_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_atom1215  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_atom1215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_atom1215	= { FOLLOW_STRING_in_atom1215_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_in_atom1221  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_in_atom1221_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_in_atom1221	= { FOLLOW_INTEGER_in_atom1221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_atom1227  */
static	ANTLR3_BITWORD FOLLOW_54_in_atom1227_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_54_in_atom1227	= { FOLLOW_54_in_atom1227_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_or_in_value1242  */
static	ANTLR3_BITWORD FOLLOW_or_in_value1242_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_or_in_value1242	= { FOLLOW_or_in_value1242_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_and_in_or1257  */
static	ANTLR3_BITWORD FOLLOW_and_in_or1257_bits[]	= { ANTLR3_UINT64_LIT(0x0800000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_and_in_or1257	= { FOLLOW_and_in_or1257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_59_in_or1260  */
static	ANTLR3_BITWORD FOLLOW_59_in_or1260_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_59_in_or1260	= { FOLLOW_59_in_or1260_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_and_in_or1264  */
static	ANTLR3_BITWORD FOLLOW_and_in_or1264_bits[]	= { ANTLR3_UINT64_LIT(0x0800000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_and_in_or1264	= { FOLLOW_and_in_or1264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comparison_in_and1349  */
static	ANTLR3_BITWORD FOLLOW_comparison_in_and1349_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000002) };
static  ANTLR3_BITSET_LIST FOLLOW_comparison_in_and1349	= { FOLLOW_comparison_in_and1349_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_and1352  */
static	ANTLR3_BITWORD FOLLOW_28_in_and1352_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_and1352	= { FOLLOW_28_in_and1352_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comparison_in_and1356  */
static	ANTLR3_BITWORD FOLLOW_comparison_in_and1356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000010000002) };
static  ANTLR3_BITSET_LIST FOLLOW_comparison_in_and1356	= { FOLLOW_comparison_in_and1356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addition_in_comparison1427  */
static	ANTLR3_BITWORD FOLLOW_addition_in_comparison1427_bits[]	= { ANTLR3_UINT64_LIT(0x00001F8000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addition_in_comparison1427	= { FOLLOW_addition_in_comparison1427_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_comparison1431  */
static	ANTLR3_BITWORD FOLLOW_42_in_comparison1431_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_comparison1431	= { FOLLOW_42_in_comparison1431_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_comparison1433  */
static	ANTLR3_BITWORD FOLLOW_41_in_comparison1433_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_comparison1433	= { FOLLOW_41_in_comparison1433_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_comparison1435  */
static	ANTLR3_BITWORD FOLLOW_39_in_comparison1435_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_comparison1435	= { FOLLOW_39_in_comparison1435_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_comparison1437  */
static	ANTLR3_BITWORD FOLLOW_43_in_comparison1437_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_comparison1437	= { FOLLOW_43_in_comparison1437_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_comparison1439  */
static	ANTLR3_BITWORD FOLLOW_40_in_comparison1439_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_comparison1439	= { FOLLOW_40_in_comparison1439_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_comparison1441  */
static	ANTLR3_BITWORD FOLLOW_44_in_comparison1441_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_comparison1441	= { FOLLOW_44_in_comparison1441_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addition_in_comparison1446  */
static	ANTLR3_BITWORD FOLLOW_addition_in_comparison1446_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addition_in_comparison1446	= { FOLLOW_addition_in_comparison1446_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplication_in_addition1496  */
static	ANTLR3_BITWORD FOLLOW_multiplication_in_addition1496_bits[]	= { ANTLR3_UINT64_LIT(0x0000000500000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplication_in_addition1496	= { FOLLOW_multiplication_in_addition1496_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_32_in_addition1500  */
static	ANTLR3_BITWORD FOLLOW_32_in_addition1500_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_32_in_addition1500	= { FOLLOW_32_in_addition1500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_addition1502  */
static	ANTLR3_BITWORD FOLLOW_34_in_addition1502_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_addition1502	= { FOLLOW_34_in_addition1502_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multiplication_in_addition1507  */
static	ANTLR3_BITWORD FOLLOW_multiplication_in_addition1507_bits[]	= { ANTLR3_UINT64_LIT(0x0000000500000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multiplication_in_addition1507	= { FOLLOW_multiplication_in_addition1507_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atom_in_multiplication1563  */
static	ANTLR3_BITWORD FOLLOW_atom_in_multiplication1563_bits[]	= { ANTLR3_UINT64_LIT(0x0000000880000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atom_in_multiplication1563	= { FOLLOW_atom_in_multiplication1563_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_31_in_multiplication1567  */
static	ANTLR3_BITWORD FOLLOW_31_in_multiplication1567_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_31_in_multiplication1567	= { FOLLOW_31_in_multiplication1567_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_multiplication1569  */
static	ANTLR3_BITWORD FOLLOW_35_in_multiplication1569_bits[]	= { ANTLR3_UINT64_LIT(0x0040000001028000) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_multiplication1569	= { FOLLOW_35_in_multiplication1569_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atom_in_multiplication1574  */
static	ANTLR3_BITWORD FOLLOW_atom_in_multiplication1574_bits[]	= { ANTLR3_UINT64_LIT(0x0000000880000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atom_in_multiplication1574	= { FOLLOW_atom_in_multiplication1574_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start program
 * Tiger.g:51:1: program : instructions ;
 */
static TigerParser_program_return
program(pTigerParser ctx)
{
    TigerParser_program_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_instructions_return instructions1;
    #undef	RETURN_TYPE_instructions1
    #define	RETURN_TYPE_instructions1 TigerParser_instructions_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    instructions1.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Tiger.g:51:9: ( instructions )
        // Tiger.g:51:11: instructions
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_instructions_in_program353);
            instructions1=instructions(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprogramEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, instructions1.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprogramEx; /* Prevent compiler warnings */
    ruleprogramEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end program */

/**
 * $ANTLR start instructions
 * Tiger.g:54:1: instructions : ( instruction | '(' i1= instruction ( ';' i2= instruction )* ')' -> $i1 ( $i2)* );
 */
static TigerParser_instructions_return
instructions(pTigerParser ctx)
{
    TigerParser_instructions_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal3;
    pANTLR3_COMMON_TOKEN    char_literal4;
    pANTLR3_COMMON_TOKEN    char_literal5;
    TigerParser_instruction_return i1;
    #undef	RETURN_TYPE_i1
    #define	RETURN_TYPE_i1 TigerParser_instruction_return

    TigerParser_instruction_return i2;
    #undef	RETURN_TYPE_i2
    #define	RETURN_TYPE_i2 TigerParser_instruction_return

    TigerParser_instruction_return instruction2;
    #undef	RETURN_TYPE_instruction2
    #define	RETURN_TYPE_instruction2 TigerParser_instruction_return

    pANTLR3_BASE_TREE char_literal3_tree;
    pANTLR3_BASE_TREE char_literal4_tree;
    pANTLR3_BASE_TREE char_literal5_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_38;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_29;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_30;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_instruction;
    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal3       = NULL;
    char_literal4       = NULL;
    char_literal5       = NULL;
    i1.tree = NULL;

    i2.tree = NULL;

    instruction2.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal3_tree   = NULL;
    char_literal4_tree   = NULL;
    char_literal5_tree   = NULL;

    stream_38   = NULL;
    #define CREATE_stream_38  if (stream_38 == NULL) {stream_38 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 38"); } 
    stream_29   = NULL;
    #define CREATE_stream_29  if (stream_29 == NULL) {stream_29 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 29"); } 
    stream_30   = NULL;
    #define CREATE_stream_30  if (stream_30 == NULL) {stream_30 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 30"); } 
    stream_instruction   = NULL;
    #define CREATE_stream_instruction  if (stream_instruction == NULL) {stream_instruction = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule instruction"); }

    retval.tree  = NULL;

    {
        {
            //  Tiger.g:55:3: ( instruction | '(' i1= instruction ( ';' i2= instruction )* ')' -> $i1 ( $i2)* )

            ANTLR3_UINT32 alt2;

            alt2=2;

            switch ( LA(1) )
            {
            case ID:
            case INTEGER:
            case STRING:
            case 45:
            case 49:
            case 51:
            case 53:
            case 54:
            case 58:
            	{
            		alt2=1;
            	}
                break;
            case 29:
            	{
            		alt2=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 2;
                EXCEPTION->state        = 0;


                goto ruleinstructionsEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // Tiger.g:55:5: instruction
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_instruction_in_instructions365);
        	        instruction2=instruction(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionsEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, instruction2.tree);

        	    }
        	    break;
        	case 2:
        	    // Tiger.g:56:5: '(' i1= instruction ( ';' i2= instruction )* ')'
        	    {
        	        char_literal3 = (pANTLR3_COMMON_TOKEN) MATCHT(29, &FOLLOW_29_in_instructions371);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionsEx;
        	        }
        	         
        	        CREATE_stream_29; stream_29->add(stream_29, char_literal3, NULL);


        	        FOLLOWPUSH(FOLLOW_instruction_in_instructions375);
        	        i1=instruction(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionsEx;
        	        }

        	        CREATE_stream_instruction; stream_instruction->add(stream_instruction, i1.tree, NULL);

        	        // Tiger.g:56:24: ( ';' i2= instruction )*

        	        for (;;)
        	        {
        	            int alt1=2;
        	            switch ( LA(1) )
        	            {
        	            case 38:
        	            	{
        	            		alt1=1;
        	            	}
        	                break;

        	            }

        	            switch (alt1)
        	            {
        	        	case 1:
        	        	    // Tiger.g:56:25: ';' i2= instruction
        	        	    {
        	        	        char_literal4 = (pANTLR3_COMMON_TOKEN) MATCHT(38, &FOLLOW_38_in_instructions378);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleinstructionsEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_38; stream_38->add(stream_38, char_literal4, NULL);


        	        	        FOLLOWPUSH(FOLLOW_instruction_in_instructions382);
        	        	        i2=instruction(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleinstructionsEx;
        	        	        }

        	        	        CREATE_stream_instruction; stream_instruction->add(stream_instruction, i2.tree, NULL);

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop1;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop1: ; /* Jump out to here if this rule does not match */


        	        char_literal5 = (pANTLR3_COMMON_TOKEN) MATCHT(30, &FOLLOW_30_in_instructions386);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionsEx;
        	        }
        	         
        	        CREATE_stream_30; stream_30->add(stream_30, char_literal5, NULL);


        	        /* AST REWRITE
        	         * elements          : i1, i2
        	         * token labels      : 
        	         * rule labels       : i1, i2, retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_i1;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_i2;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_i1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token i1", i1.tree != NULL ? i1.tree : NULL);
        	        	stream_i2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token i2", i2.tree != NULL ? i2.tree : NULL);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 56:81: -> $i1 ( $i2)*
        	        	{
        	        	    ADAPTOR->addChild(ADAPTOR, root_0, stream_i1 == NULL ? NULL : stream_i1->nextTree(stream_i1));

        	        	    // Tiger.g:56:89: ( $i2)*
        	        	    {
        	        	    	while ( (stream_i2 != NULL && stream_i2->hasNext(stream_i2))  )
        	        	    	{
        	        	    		ADAPTOR->addChild(ADAPTOR, root_0, stream_i2 == NULL ? NULL : stream_i2->nextTree(stream_i2));

        	        	    	}
        	        	    	if (stream_i2 != NULL) stream_i2->reset(stream_i2);

        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_i1 != NULL) stream_i1->free(stream_i1);
        	        	if (stream_i2 != NULL) stream_i2->free(stream_i2);
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleinstructionsEx; /* Prevent compiler warnings */
    ruleinstructionsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_38 != NULL) stream_38->free(stream_38);
        if (stream_29 != NULL) stream_29->free(stream_29);
        if (stream_30 != NULL) stream_30->free(stream_30);
        if (stream_instruction != NULL) stream_instruction->free(stream_instruction);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end instructions */

/**
 * $ANTLR start params
 * Tiger.g:60:1: params : '(' (p1= param ( ',' p2= param )* )? ')' -> ^( PARAMS ( $p1 ( $p2)* )? ) ;
 */
static TigerParser_params_return
params(pTigerParser ctx)
{
    TigerParser_params_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal6;
    pANTLR3_COMMON_TOKEN    char_literal7;
    pANTLR3_COMMON_TOKEN    char_literal8;
    TigerParser_param_return p1;
    #undef	RETURN_TYPE_p1
    #define	RETURN_TYPE_p1 TigerParser_param_return

    TigerParser_param_return p2;
    #undef	RETURN_TYPE_p2
    #define	RETURN_TYPE_p2 TigerParser_param_return

    pANTLR3_BASE_TREE char_literal6_tree;
    pANTLR3_BASE_TREE char_literal7_tree;
    pANTLR3_BASE_TREE char_literal8_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_33;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_29;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_30;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_param;
    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal6       = NULL;
    char_literal7       = NULL;
    char_literal8       = NULL;
    p1.tree = NULL;

    p2.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal6_tree   = NULL;
    char_literal7_tree   = NULL;
    char_literal8_tree   = NULL;

    stream_33   = NULL;
    #define CREATE_stream_33  if (stream_33 == NULL) {stream_33 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 33"); } 
    stream_29   = NULL;
    #define CREATE_stream_29  if (stream_29 == NULL) {stream_29 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 29"); } 
    stream_30   = NULL;
    #define CREATE_stream_30  if (stream_30 == NULL) {stream_30 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 30"); } 
    stream_param   = NULL;
    #define CREATE_stream_param  if (stream_param == NULL) {stream_param = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule param"); }

    retval.tree  = NULL;

    {
        // Tiger.g:61:3: ( '(' (p1= param ( ',' p2= param )* )? ')' -> ^( PARAMS ( $p1 ( $p2)* )? ) )
        // Tiger.g:61:5: '(' (p1= param ( ',' p2= param )* )? ')'
        {
            char_literal6 = (pANTLR3_COMMON_TOKEN) MATCHT(29, &FOLLOW_29_in_params440);
            if  (HASEXCEPTION())
            {
                goto ruleparamsEx;
            }
             
            CREATE_stream_29; stream_29->add(stream_29, char_literal6, NULL);


            // Tiger.g:61:9: (p1= param ( ',' p2= param )* )?
            {
                int alt4=2;
                switch ( LA(1) )
                {
                    case ID:
                    	{
                    		alt4=1;
                    	}
                        break;
                }

                switch (alt4)
                {
            	case 1:
            	    // Tiger.g:61:11: p1= param ( ',' p2= param )*
            	    {
            	        FOLLOWPUSH(FOLLOW_param_in_params446);
            	        p1=param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparamsEx;
            	        }

            	        CREATE_stream_param; stream_param->add(stream_param, p1.tree, NULL);

            	        // Tiger.g:61:20: ( ',' p2= param )*

            	        for (;;)
            	        {
            	            int alt3=2;
            	            switch ( LA(1) )
            	            {
            	            case 33:
            	            	{
            	            		alt3=1;
            	            	}
            	                break;

            	            }

            	            switch (alt3)
            	            {
            	        	case 1:
            	        	    // Tiger.g:61:21: ',' p2= param
            	        	    {
            	        	        char_literal7 = (pANTLR3_COMMON_TOKEN) MATCHT(33, &FOLLOW_33_in_params449);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleparamsEx;
            	        	        }
            	        	         
            	        	        CREATE_stream_33; stream_33->add(stream_33, char_literal7, NULL);


            	        	        FOLLOWPUSH(FOLLOW_param_in_params453);
            	        	        p2=param(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleparamsEx;
            	        	        }

            	        	        CREATE_stream_param; stream_param->add(stream_param, p2.tree, NULL);

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop3;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop3: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            char_literal8 = (pANTLR3_COMMON_TOKEN) MATCHT(30, &FOLLOW_30_in_params459);
            if  (HASEXCEPTION())
            {
                goto ruleparamsEx;
            }
             
            CREATE_stream_30; stream_30->add(stream_30, char_literal8, NULL);


            /* AST REWRITE
             * elements          : p2, p1
             * token labels      : 
             * rule labels       : p1, p2, retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_p1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_p2;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_p1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token p1", p1.tree != NULL ? p1.tree : NULL);
            	stream_p2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token p2", p2.tree != NULL ? p2.tree : NULL);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 61:81: -> ^( PARAMS ( $p1 ( $p2)* )? )
            	{
            	    // Tiger.g:61:84: ^( PARAMS ( $p1 ( $p2)* )? )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PARAMS, (pANTLR3_UINT8)"PARAMS")
            	        , root_1));

            	        // Tiger.g:61:93: ( $p1 ( $p2)* )?
            	        {
            	        	if ( (stream_p2 != NULL && stream_p2->hasNext(stream_p2)) || (stream_p1 != NULL && stream_p1->hasNext(stream_p1))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_p1 == NULL ? NULL : stream_p1->nextTree(stream_p1));

            	        		// Tiger.g:61:99: ( $p2)*
            	        		{
            	        			while ( (stream_p2 != NULL && stream_p2->hasNext(stream_p2))  )
            	        			{
            	        				ADAPTOR->addChild(ADAPTOR, root_1, stream_p2 == NULL ? NULL : stream_p2->nextTree(stream_p2));

            	        			}
            	        			if (stream_p2 != NULL) stream_p2->reset(stream_p2);

            	        		}

            	        	}
            	        	if ( stream_p2 != NULL) stream_p2->reset(stream_p2);
            	        	if ( stream_p1 != NULL) stream_p1->reset(stream_p1);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_p1 != NULL) stream_p1->free(stream_p1);
            	if (stream_p2 != NULL) stream_p2->free(stream_p2);
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparamsEx; /* Prevent compiler warnings */
    ruleparamsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_33 != NULL) stream_33->free(stream_33);
        if (stream_29 != NULL) stream_29->free(stream_29);
        if (stream_30 != NULL) stream_30->free(stream_30);
        if (stream_param != NULL) stream_param->free(stream_param);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end params */

/**
 * $ANTLR start param
 * Tiger.g:63:1: param : id1= ID ':' id2= ID -> ^( PARAM $id1 $id2) ;
 */
static TigerParser_param_return
param(pTigerParser ctx)
{
    TigerParser_param_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    id1;
    pANTLR3_COMMON_TOKEN    id2;
    pANTLR3_COMMON_TOKEN    char_literal9;

    pANTLR3_BASE_TREE id1_tree;
    pANTLR3_BASE_TREE id2_tree;
    pANTLR3_BASE_TREE char_literal9_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_36;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;

    /* Initialize rule variables
     */

    root_0 = NULL;

    id1       = NULL;
    id2       = NULL;
    char_literal9       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    id1_tree   = NULL;
    id2_tree   = NULL;
    char_literal9_tree   = NULL;

    stream_36   = NULL;
    #define CREATE_stream_36  if (stream_36 == NULL) {stream_36 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 36"); } 
    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 

    retval.tree  = NULL;

    {
        // Tiger.g:64:3: (id1= ID ':' id2= ID -> ^( PARAM $id1 $id2) )
        // Tiger.g:64:5: id1= ID ':' id2= ID
        {
            id1 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_param528);
            if  (HASEXCEPTION())
            {
                goto ruleparamEx;
            }
             
            CREATE_stream_ID; stream_ID->add(stream_ID, id1, NULL);


            char_literal9 = (pANTLR3_COMMON_TOKEN) MATCHT(36, &FOLLOW_36_in_param530);
            if  (HASEXCEPTION())
            {
                goto ruleparamEx;
            }
             
            CREATE_stream_36; stream_36->add(stream_36, char_literal9, NULL);


            id2 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_param534);
            if  (HASEXCEPTION())
            {
                goto ruleparamEx;
            }
             
            CREATE_stream_ID; stream_ID->add(stream_ID, id2, NULL);


            /* AST REWRITE
             * elements          : id2, id1
             * token labels      : id2, id1
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_id2;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_id1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_id2=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token id2", id2);
            	stream_id1=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token id1", id1);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 64:81: -> ^( PARAM $id1 $id2)
            	{
            	    // Tiger.g:64:84: ^( PARAM $id1 $id2)
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PARAM, (pANTLR3_UINT8)"PARAM")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_id1 == NULL ? NULL : stream_id1->nextNode(stream_id1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_id2 == NULL ? NULL : stream_id2->nextNode(stream_id2));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_id2 != NULL) stream_id2->free(stream_id2); 
            	if (stream_id1 != NULL) stream_id1->free(stream_id1); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparamEx; /* Prevent compiler warnings */
    ruleparamEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_36 != NULL) stream_36->free(stream_36);
        if (stream_ID != NULL) stream_ID->free(stream_ID);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end param */

/**
 * $ANTLR start declararion
 * Tiger.g:68:1: declararion : ( 'var' name= ID ( ':' type= ID )? ':=' value -> ^( VAR $name ( $type)? value ) | 'function' name= ID params ( ':' return_type= ID )? '=' instructions -> ^( FUNC $name params ( $return_type)? instructions ) );
 */
static TigerParser_declararion_return
declararion(pTigerParser ctx)
{
    TigerParser_declararion_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    name;
    pANTLR3_COMMON_TOKEN    type;
    pANTLR3_COMMON_TOKEN    return_type;
    pANTLR3_COMMON_TOKEN    string_literal10;
    pANTLR3_COMMON_TOKEN    char_literal11;
    pANTLR3_COMMON_TOKEN    string_literal12;
    pANTLR3_COMMON_TOKEN    string_literal14;
    pANTLR3_COMMON_TOKEN    char_literal16;
    pANTLR3_COMMON_TOKEN    char_literal17;
    TigerParser_value_return value13;
    #undef	RETURN_TYPE_value13
    #define	RETURN_TYPE_value13 TigerParser_value_return

    TigerParser_params_return params15;
    #undef	RETURN_TYPE_params15
    #define	RETURN_TYPE_params15 TigerParser_params_return

    TigerParser_instructions_return instructions18;
    #undef	RETURN_TYPE_instructions18
    #define	RETURN_TYPE_instructions18 TigerParser_instructions_return

    pANTLR3_BASE_TREE name_tree;
    pANTLR3_BASE_TREE type_tree;
    pANTLR3_BASE_TREE return_type_tree;
    pANTLR3_BASE_TREE string_literal10_tree;
    pANTLR3_BASE_TREE char_literal11_tree;
    pANTLR3_BASE_TREE string_literal12_tree;
    pANTLR3_BASE_TREE string_literal14_tree;
    pANTLR3_BASE_TREE char_literal16_tree;
    pANTLR3_BASE_TREE char_literal17_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_57;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_36;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_37;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_50;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_42;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_instructions;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_params;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_value;
    /* Initialize rule variables
     */

    root_0 = NULL;

    name       = NULL;
    type       = NULL;
    return_type       = NULL;
    string_literal10       = NULL;
    char_literal11       = NULL;
    string_literal12       = NULL;
    string_literal14       = NULL;
    char_literal16       = NULL;
    char_literal17       = NULL;
    value13.tree = NULL;

    params15.tree = NULL;

    instructions18.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    name_tree   = NULL;
    type_tree   = NULL;
    return_type_tree   = NULL;
    string_literal10_tree   = NULL;
    char_literal11_tree   = NULL;
    string_literal12_tree   = NULL;
    string_literal14_tree   = NULL;
    char_literal16_tree   = NULL;
    char_literal17_tree   = NULL;

    stream_57   = NULL;
    #define CREATE_stream_57  if (stream_57 == NULL) {stream_57 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 57"); } 
    stream_36   = NULL;
    #define CREATE_stream_36  if (stream_36 == NULL) {stream_36 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 36"); } 
    stream_37   = NULL;
    #define CREATE_stream_37  if (stream_37 == NULL) {stream_37 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 37"); } 
    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 
    stream_50   = NULL;
    #define CREATE_stream_50  if (stream_50 == NULL) {stream_50 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 50"); } 
    stream_42   = NULL;
    #define CREATE_stream_42  if (stream_42 == NULL) {stream_42 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 42"); } 
    stream_instructions   = NULL;
    #define CREATE_stream_instructions  if (stream_instructions == NULL) {stream_instructions = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule instructions"); }
    stream_params   = NULL;
    #define CREATE_stream_params  if (stream_params == NULL) {stream_params = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule params"); }
    stream_value   = NULL;
    #define CREATE_stream_value  if (stream_value == NULL) {stream_value = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule value"); }

    retval.tree  = NULL;

    {
        {
            //  Tiger.g:69:3: ( 'var' name= ID ( ':' type= ID )? ':=' value -> ^( VAR $name ( $type)? value ) | 'function' name= ID params ( ':' return_type= ID )? '=' instructions -> ^( FUNC $name params ( $return_type)? instructions ) )

            ANTLR3_UINT32 alt7;

            alt7=2;

            switch ( LA(1) )
            {
            case 57:
            	{
            		alt7=1;
            	}
                break;
            case 50:
            	{
            		alt7=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 7;
                EXCEPTION->state        = 0;


                goto ruledeclararionEx;

            }

            switch (alt7)
            {
        	case 1:
        	    // Tiger.g:69:5: 'var' name= ID ( ':' type= ID )? ':=' value
        	    {
        	        string_literal10 = (pANTLR3_COMMON_TOKEN) MATCHT(57, &FOLLOW_57_in_declararion618);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclararionEx;
        	        }
        	         
        	        CREATE_stream_57; stream_57->add(stream_57, string_literal10, NULL);


        	        name = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_declararion622);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclararionEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, name, NULL);


        	        // Tiger.g:69:19: ( ':' type= ID )?
        	        {
        	            int alt5=2;
        	            switch ( LA(1) )
        	            {
        	                case 36:
        	                	{
        	                		alt5=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt5)
        	            {
        	        	case 1:
        	        	    // Tiger.g:69:20: ':' type= ID
        	        	    {
        	        	        char_literal11 = (pANTLR3_COMMON_TOKEN) MATCHT(36, &FOLLOW_36_in_declararion625);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclararionEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_36; stream_36->add(stream_36, char_literal11, NULL);


        	        	        type = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_declararion629);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclararionEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_ID; stream_ID->add(stream_ID, type, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        string_literal12 = (pANTLR3_COMMON_TOKEN) MATCHT(37, &FOLLOW_37_in_declararion633);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclararionEx;
        	        }
        	         
        	        CREATE_stream_37; stream_37->add(stream_37, string_literal12, NULL);


        	        FOLLOWPUSH(FOLLOW_value_in_declararion635);
        	        value13=value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclararionEx;
        	        }

        	        CREATE_stream_value; stream_value->add(stream_value, value13.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : type, value, name
        	         * token labels      : name, type
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_name;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_type;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_name=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token name", name);
        	        	stream_type=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token type", type);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 69:81: -> ^( VAR $name ( $type)? value )
        	        	{
        	        	    // Tiger.g:69:84: ^( VAR $name ( $type)? value )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, VAR, (pANTLR3_UINT8)"VAR")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_name == NULL ? NULL : stream_name->nextNode(stream_name));

        	        	        // Tiger.g:69:97: ( $type)?
        	        	        {
        	        	        	if ( (stream_type != NULL && stream_type->hasNext(stream_type))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_type == NULL ? NULL : stream_type->nextNode(stream_type));

        	        	        	}
        	        	        	if ( stream_type != NULL) stream_type->reset(stream_type);

        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_value == NULL ? NULL : stream_value->nextTree(stream_value));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_name != NULL) stream_name->free(stream_name); 
        	        	if (stream_type != NULL) stream_type->free(stream_type); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // Tiger.g:70:5: 'function' name= ID params ( ':' return_type= ID )? '=' instructions
        	    {
        	        string_literal14 = (pANTLR3_COMMON_TOKEN) MATCHT(50, &FOLLOW_50_in_declararion692);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclararionEx;
        	        }
        	         
        	        CREATE_stream_50; stream_50->add(stream_50, string_literal14, NULL);


        	        name = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_declararion696);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclararionEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, name, NULL);


        	        FOLLOWPUSH(FOLLOW_params_in_declararion698);
        	        params15=params(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclararionEx;
        	        }

        	        CREATE_stream_params; stream_params->add(stream_params, params15.tree, NULL);

        	        // Tiger.g:70:31: ( ':' return_type= ID )?
        	        {
        	            int alt6=2;
        	            switch ( LA(1) )
        	            {
        	                case 36:
        	                	{
        	                		alt6=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt6)
        	            {
        	        	case 1:
        	        	    // Tiger.g:70:32: ':' return_type= ID
        	        	    {
        	        	        char_literal16 = (pANTLR3_COMMON_TOKEN) MATCHT(36, &FOLLOW_36_in_declararion701);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclararionEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_36; stream_36->add(stream_36, char_literal16, NULL);


        	        	        return_type = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_declararion705);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclararionEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_ID; stream_ID->add(stream_ID, return_type, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        char_literal17 = (pANTLR3_COMMON_TOKEN) MATCHT(42, &FOLLOW_42_in_declararion709);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclararionEx;
        	        }
        	         
        	        CREATE_stream_42; stream_42->add(stream_42, char_literal17, NULL);


        	        FOLLOWPUSH(FOLLOW_instructions_in_declararion711);
        	        instructions18=instructions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclararionEx;
        	        }

        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, instructions18.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : name, instructions, params, return_type
        	         * token labels      : return_type, name
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_return_type;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_name;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_return_type=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token return_type", return_type);
        	        	stream_name=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token name", name);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 70:81: -> ^( FUNC $name params ( $return_type)? instructions )
        	        	{
        	        	    // Tiger.g:70:84: ^( FUNC $name params ( $return_type)? instructions )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FUNC, (pANTLR3_UINT8)"FUNC")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_name == NULL ? NULL : stream_name->nextNode(stream_name));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_params == NULL ? NULL : stream_params->nextTree(stream_params));

        	        	        // Tiger.g:70:105: ( $return_type)?
        	        	        {
        	        	        	if ( (stream_return_type != NULL && stream_return_type->hasNext(stream_return_type))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_return_type == NULL ? NULL : stream_return_type->nextNode(stream_return_type));

        	        	        	}
        	        	        	if ( stream_return_type != NULL) stream_return_type->reset(stream_return_type);

        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instructions == NULL ? NULL : stream_instructions->nextTree(stream_instructions));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_return_type != NULL) stream_return_type->free(stream_return_type); 
        	        	if (stream_name != NULL) stream_name->free(stream_name); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledeclararionEx; /* Prevent compiler warnings */
    ruledeclararionEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_57 != NULL) stream_57->free(stream_57);
        if (stream_36 != NULL) stream_36->free(stream_36);
        if (stream_37 != NULL) stream_37->free(stream_37);
        if (stream_ID != NULL) stream_ID->free(stream_ID);
        if (stream_50 != NULL) stream_50->free(stream_50);
        if (stream_42 != NULL) stream_42->free(stream_42);
        if (stream_instructions != NULL) stream_instructions->free(stream_instructions);
        if (stream_params != NULL) stream_params->free(stream_params);
        if (stream_value != NULL) stream_value->free(stream_value);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end declararion */

/**
 * $ANTLR start instruction
 * Tiger.g:76:1: instruction : ( 'let' ( declararion )+ 'in' ( instructions )* 'end' -> ^( LET ( declararion )+ ( instructions )* ) | ID ':=' value -> ^( ASSIGNE ID value ) | 'if' value 'then' i1= instructions ( options {greedy=true; } : 'else' i2= instructions )? -> ^( IF value $i1 ( $i2)? ) | 'while' value 'do' instructions -> ^( WHILE value instructions ) | 'for' ID ':=' v1= value 'to' v2= value 'do' instructions -> ^( FOR ID $v1 $v2 instructions ) | 'break' | value );
 */
static TigerParser_instruction_return
instruction(pTigerParser ctx)
{
    TigerParser_instruction_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal19;
    pANTLR3_COMMON_TOKEN    string_literal21;
    pANTLR3_COMMON_TOKEN    string_literal23;
    pANTLR3_COMMON_TOKEN    ID24;
    pANTLR3_COMMON_TOKEN    string_literal25;
    pANTLR3_COMMON_TOKEN    string_literal27;
    pANTLR3_COMMON_TOKEN    string_literal29;
    pANTLR3_COMMON_TOKEN    string_literal30;
    pANTLR3_COMMON_TOKEN    string_literal31;
    pANTLR3_COMMON_TOKEN    string_literal33;
    pANTLR3_COMMON_TOKEN    string_literal35;
    pANTLR3_COMMON_TOKEN    ID36;
    pANTLR3_COMMON_TOKEN    string_literal37;
    pANTLR3_COMMON_TOKEN    string_literal38;
    pANTLR3_COMMON_TOKEN    string_literal39;
    pANTLR3_COMMON_TOKEN    string_literal41;
    TigerParser_instructions_return i1;
    #undef	RETURN_TYPE_i1
    #define	RETURN_TYPE_i1 TigerParser_instructions_return

    TigerParser_instructions_return i2;
    #undef	RETURN_TYPE_i2
    #define	RETURN_TYPE_i2 TigerParser_instructions_return

    TigerParser_value_return v1;
    #undef	RETURN_TYPE_v1
    #define	RETURN_TYPE_v1 TigerParser_value_return

    TigerParser_value_return v2;
    #undef	RETURN_TYPE_v2
    #define	RETURN_TYPE_v2 TigerParser_value_return

    TigerParser_declararion_return declararion20;
    #undef	RETURN_TYPE_declararion20
    #define	RETURN_TYPE_declararion20 TigerParser_declararion_return

    TigerParser_instructions_return instructions22;
    #undef	RETURN_TYPE_instructions22
    #define	RETURN_TYPE_instructions22 TigerParser_instructions_return

    TigerParser_value_return value26;
    #undef	RETURN_TYPE_value26
    #define	RETURN_TYPE_value26 TigerParser_value_return

    TigerParser_value_return value28;
    #undef	RETURN_TYPE_value28
    #define	RETURN_TYPE_value28 TigerParser_value_return

    TigerParser_value_return value32;
    #undef	RETURN_TYPE_value32
    #define	RETURN_TYPE_value32 TigerParser_value_return

    TigerParser_instructions_return instructions34;
    #undef	RETURN_TYPE_instructions34
    #define	RETURN_TYPE_instructions34 TigerParser_instructions_return

    TigerParser_instructions_return instructions40;
    #undef	RETURN_TYPE_instructions40
    #define	RETURN_TYPE_instructions40 TigerParser_instructions_return

    TigerParser_value_return value42;
    #undef	RETURN_TYPE_value42
    #define	RETURN_TYPE_value42 TigerParser_value_return

    pANTLR3_BASE_TREE string_literal19_tree;
    pANTLR3_BASE_TREE string_literal21_tree;
    pANTLR3_BASE_TREE string_literal23_tree;
    pANTLR3_BASE_TREE ID24_tree;
    pANTLR3_BASE_TREE string_literal25_tree;
    pANTLR3_BASE_TREE string_literal27_tree;
    pANTLR3_BASE_TREE string_literal29_tree;
    pANTLR3_BASE_TREE string_literal30_tree;
    pANTLR3_BASE_TREE string_literal31_tree;
    pANTLR3_BASE_TREE string_literal33_tree;
    pANTLR3_BASE_TREE string_literal35_tree;
    pANTLR3_BASE_TREE ID36_tree;
    pANTLR3_BASE_TREE string_literal37_tree;
    pANTLR3_BASE_TREE string_literal38_tree;
    pANTLR3_BASE_TREE string_literal39_tree;
    pANTLR3_BASE_TREE string_literal41_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_55;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_46;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_47;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_58;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_48;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_37;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_49;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_51;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_52;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_53;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_instructions;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_declararion;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_value;
    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal19       = NULL;
    string_literal21       = NULL;
    string_literal23       = NULL;
    ID24       = NULL;
    string_literal25       = NULL;
    string_literal27       = NULL;
    string_literal29       = NULL;
    string_literal30       = NULL;
    string_literal31       = NULL;
    string_literal33       = NULL;
    string_literal35       = NULL;
    ID36       = NULL;
    string_literal37       = NULL;
    string_literal38       = NULL;
    string_literal39       = NULL;
    string_literal41       = NULL;
    i1.tree = NULL;

    i2.tree = NULL;

    v1.tree = NULL;

    v2.tree = NULL;

    declararion20.tree = NULL;

    instructions22.tree = NULL;

    value26.tree = NULL;

    value28.tree = NULL;

    value32.tree = NULL;

    instructions34.tree = NULL;

    instructions40.tree = NULL;

    value42.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal19_tree   = NULL;
    string_literal21_tree   = NULL;
    string_literal23_tree   = NULL;
    ID24_tree   = NULL;
    string_literal25_tree   = NULL;
    string_literal27_tree   = NULL;
    string_literal29_tree   = NULL;
    string_literal30_tree   = NULL;
    string_literal31_tree   = NULL;
    string_literal33_tree   = NULL;
    string_literal35_tree   = NULL;
    ID36_tree   = NULL;
    string_literal37_tree   = NULL;
    string_literal38_tree   = NULL;
    string_literal39_tree   = NULL;
    string_literal41_tree   = NULL;

    stream_55   = NULL;
    #define CREATE_stream_55  if (stream_55 == NULL) {stream_55 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 55"); } 
    stream_56   = NULL;
    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 56"); } 
    stream_46   = NULL;
    #define CREATE_stream_46  if (stream_46 == NULL) {stream_46 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 46"); } 
    stream_47   = NULL;
    #define CREATE_stream_47  if (stream_47 == NULL) {stream_47 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 47"); } 
    stream_58   = NULL;
    #define CREATE_stream_58  if (stream_58 == NULL) {stream_58 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 58"); } 
    stream_48   = NULL;
    #define CREATE_stream_48  if (stream_48 == NULL) {stream_48 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 48"); } 
    stream_37   = NULL;
    #define CREATE_stream_37  if (stream_37 == NULL) {stream_37 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 37"); } 
    stream_49   = NULL;
    #define CREATE_stream_49  if (stream_49 == NULL) {stream_49 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 49"); } 
    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 
    stream_51   = NULL;
    #define CREATE_stream_51  if (stream_51 == NULL) {stream_51 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 51"); } 
    stream_52   = NULL;
    #define CREATE_stream_52  if (stream_52 == NULL) {stream_52 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 52"); } 
    stream_53   = NULL;
    #define CREATE_stream_53  if (stream_53 == NULL) {stream_53 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 53"); } 
    stream_instructions   = NULL;
    #define CREATE_stream_instructions  if (stream_instructions == NULL) {stream_instructions = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule instructions"); }
    stream_declararion   = NULL;
    #define CREATE_stream_declararion  if (stream_declararion == NULL) {stream_declararion = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule declararion"); }
    stream_value   = NULL;
    #define CREATE_stream_value  if (stream_value == NULL) {stream_value = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule value"); }

    retval.tree  = NULL;

    {
        {
            //  Tiger.g:77:3: ( 'let' ( declararion )+ 'in' ( instructions )* 'end' -> ^( LET ( declararion )+ ( instructions )* ) | ID ':=' value -> ^( ASSIGNE ID value ) | 'if' value 'then' i1= instructions ( options {greedy=true; } : 'else' i2= instructions )? -> ^( IF value $i1 ( $i2)? ) | 'while' value 'do' instructions -> ^( WHILE value instructions ) | 'for' ID ':=' v1= value 'to' v2= value 'do' instructions -> ^( FOR ID $v1 $v2 instructions ) | 'break' | value )

            ANTLR3_UINT32 alt11;

            alt11=7;

            switch ( LA(1) )
            {
            case 53:
            	{
            		alt11=1;
            	}
                break;
            case ID:
            	{
            		switch ( LA(2) )
            		{
            		case 37:
            			{
            				alt11=2;
            			}
            		    break;
            		case EOF:
            		case ID:
            		case INTEGER:
            		case STRING:
            		case 28:
            		case 29:
            		case 30:
            		case 31:
            		case 32:
            		case 34:
            		case 35:
            		case 38:
            		case 39:
            		case 40:
            		case 41:
            		case 42:
            		case 43:
            		case 44:
            		case 45:
            		case 47:
            		case 48:
            		case 49:
            		case 50:
            		case 51:
            		case 52:
            		case 53:
            		case 54:
            		case 57:
            		case 58:
            		case 59:
            			{
            				alt11=7;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 11;
            		    EXCEPTION->state        = 2;


            		    goto ruleinstructionEx;

            		}

            	}
                break;
            case 51:
            	{
            		alt11=3;
            	}
                break;
            case 58:
            	{
            		alt11=4;
            	}
                break;
            case 49:
            	{
            		alt11=5;
            	}
                break;
            case 45:
            	{
            		alt11=6;
            	}
                break;
            case INTEGER:
            case STRING:
            case 54:
            	{
            		alt11=7;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 11;
                EXCEPTION->state        = 0;


                goto ruleinstructionEx;

            }

            switch (alt11)
            {
        	case 1:
        	    // Tiger.g:77:5: 'let' ( declararion )+ 'in' ( instructions )* 'end'
        	    {
        	        string_literal19 = (pANTLR3_COMMON_TOKEN) MATCHT(53, &FOLLOW_53_in_instruction755);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_53; stream_53->add(stream_53, string_literal19, NULL);


        	        // Tiger.g:77:11: ( declararion )+
        	        {
        	            int cnt8=0;

        	            for (;;)
        	            {
        	                int alt8=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case 50:
        	        	case 57:
        	        		{
        	        			alt8=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt8)
        	        	{
        	        	    case 1:
        	        	        // Tiger.g:77:11: declararion
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_declararion_in_instruction757);
        	        	            declararion20=declararion(ctx);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleinstructionEx;
        	        	            }

        	        	            CREATE_stream_declararion; stream_declararion->add(stream_declararion, declararion20.tree, NULL);

        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt8 >= 1 )
        	        		{
        	        		    goto loop8;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleinstructionEx;
        	        	}
        	        	cnt8++;
        	            }
        	            loop8: ;	/* Jump to here if this rule does not match */
        	        }

        	        string_literal21 = (pANTLR3_COMMON_TOKEN) MATCHT(52, &FOLLOW_52_in_instruction760);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_52; stream_52->add(stream_52, string_literal21, NULL);


        	        // Tiger.g:77:29: ( instructions )*

        	        for (;;)
        	        {
        	            int alt9=2;
        	            switch ( LA(1) )
        	            {
        	            case ID:
        	            case INTEGER:
        	            case STRING:
        	            case 29:
        	            case 45:
        	            case 49:
        	            case 51:
        	            case 53:
        	            case 54:
        	            case 58:
        	            	{
        	            		alt9=1;
        	            	}
        	                break;

        	            }

        	            switch (alt9)
        	            {
        	        	case 1:
        	        	    // Tiger.g:77:29: instructions
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction762);
        	        	        instructions22=instructions(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleinstructionEx;
        	        	        }

        	        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, instructions22.tree, NULL);

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop9;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop9: ; /* Jump out to here if this rule does not match */


        	        string_literal23 = (pANTLR3_COMMON_TOKEN) MATCHT(48, &FOLLOW_48_in_instruction765);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_48; stream_48->add(stream_48, string_literal23, NULL);


        	        /* AST REWRITE
        	         * elements          : instructions, declararion
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 77:81: -> ^( LET ( declararion )+ ( instructions )* )
        	        	{
        	        	    // Tiger.g:77:84: ^( LET ( declararion )+ ( instructions )* )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, LET, (pANTLR3_UINT8)"LET")
        	        	        , root_1));

        	        	        if ((stream_declararion == NULL || !stream_declararion->hasNext(stream_declararion))  )
        	        	        {
        	        	            CONSTRUCTEX();
        	        	            EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;
        	        	            EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;
        	        	        }
        	        	        else
        	        	        {
        	        	        	while ( (stream_declararion->hasNext(stream_declararion))  ) {
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_declararion == NULL ? NULL : stream_declararion->nextTree(stream_declararion));

        	        	        	}
        	        	        	stream_declararion->reset(stream_declararion);

        	        	        }
        	        	        // Tiger.g:77:103: ( instructions )*
        	        	        {
        	        	        	while ( (stream_instructions != NULL && stream_instructions->hasNext(stream_instructions))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_instructions == NULL ? NULL : stream_instructions->nextTree(stream_instructions));

        	        	        	}
        	        	        	if (stream_instructions != NULL) stream_instructions->reset(stream_instructions);

        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // Tiger.g:79:5: ID ':=' value
        	    {
        	        ID24 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_instruction816);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, ID24, NULL);


        	        string_literal25 = (pANTLR3_COMMON_TOKEN) MATCHT(37, &FOLLOW_37_in_instruction818);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_37; stream_37->add(stream_37, string_literal25, NULL);


        	        FOLLOWPUSH(FOLLOW_value_in_instruction820);
        	        value26=value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_value; stream_value->add(stream_value, value26.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : value, ID
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 79:81: -> ^( ASSIGNE ID value )
        	        	{
        	        	    // Tiger.g:79:84: ^( ASSIGNE ID value )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ASSIGNE, (pANTLR3_UINT8)"ASSIGNE")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_ID == NULL ? NULL : stream_ID->nextNode(stream_ID)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_value == NULL ? NULL : stream_value->nextTree(stream_value));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 3:
        	    // Tiger.g:81:5: 'if' value 'then' i1= instructions ( options {greedy=true; } : 'else' i2= instructions )?
        	    {
        	        string_literal27 = (pANTLR3_COMMON_TOKEN) MATCHT(51, &FOLLOW_51_in_instruction899);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_51; stream_51->add(stream_51, string_literal27, NULL);


        	        FOLLOWPUSH(FOLLOW_value_in_instruction901);
        	        value28=value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_value; stream_value->add(stream_value, value28.tree, NULL);

        	        string_literal29 = (pANTLR3_COMMON_TOKEN) MATCHT(55, &FOLLOW_55_in_instruction903);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_55; stream_55->add(stream_55, string_literal29, NULL);


        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction907);
        	        i1=instructions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, i1.tree, NULL);

        	        // Tiger.g:82:5: ( options {greedy=true; } : 'else' i2= instructions )?
        	        {
        	            int alt10=2;
        	            switch ( LA(1) )
        	            {
        	                case 47:
        	                	{
        	                		alt10=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt10)
        	            {
        	        	case 1:
        	        	    // Tiger.g:82:31: 'else' i2= instructions
        	        	    {
        	        	        string_literal30 = (pANTLR3_COMMON_TOKEN) MATCHT(47, &FOLLOW_47_in_instruction923);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleinstructionEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_47; stream_47->add(stream_47, string_literal30, NULL);


        	        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction927);
        	        	        i2=instructions(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleinstructionEx;
        	        	        }

        	        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, i2.tree, NULL);

        	        	    }
        	        	    break;

        	            }
        	        }

        	        /* AST REWRITE
        	         * elements          : value, i2, i1
        	         * token labels      : 
        	         * rule labels       : i1, i2, retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_i1;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_i2;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_i1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token i1", i1.tree != NULL ? i1.tree : NULL);
        	        	stream_i2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token i2", i2.tree != NULL ? i2.tree : NULL);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 82:81: -> ^( IF value $i1 ( $i2)? )
        	        	{
        	        	    // Tiger.g:82:84: ^( IF value $i1 ( $i2)? )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IF, (pANTLR3_UINT8)"IF")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_value == NULL ? NULL : stream_value->nextTree(stream_value));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_i1 == NULL ? NULL : stream_i1->nextTree(stream_i1));

        	        	        // Tiger.g:82:100: ( $i2)?
        	        	        {
        	        	        	if ( (stream_i2 != NULL && stream_i2->hasNext(stream_i2))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_i2 == NULL ? NULL : stream_i2->nextTree(stream_i2));

        	        	        	}
        	        	        	if ( stream_i2 != NULL) stream_i2->reset(stream_i2);

        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_i1 != NULL) stream_i1->free(stream_i1);
        	        	if (stream_i2 != NULL) stream_i2->free(stream_i2);
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 4:
        	    // Tiger.g:83:5: 'while' value 'do' instructions
        	    {
        	        string_literal31 = (pANTLR3_COMMON_TOKEN) MATCHT(58, &FOLLOW_58_in_instruction975);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_58; stream_58->add(stream_58, string_literal31, NULL);


        	        FOLLOWPUSH(FOLLOW_value_in_instruction977);
        	        value32=value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_value; stream_value->add(stream_value, value32.tree, NULL);

        	        string_literal33 = (pANTLR3_COMMON_TOKEN) MATCHT(46, &FOLLOW_46_in_instruction979);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_46; stream_46->add(stream_46, string_literal33, NULL);


        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction981);
        	        instructions34=instructions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, instructions34.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : instructions, value
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 83:81: -> ^( WHILE value instructions )
        	        	{
        	        	    // Tiger.g:83:84: ^( WHILE value instructions )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WHILE, (pANTLR3_UINT8)"WHILE")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_value == NULL ? NULL : stream_value->nextTree(stream_value));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instructions == NULL ? NULL : stream_instructions->nextTree(stream_instructions));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 5:
        	    // Tiger.g:84:5: 'for' ID ':=' v1= value 'to' v2= value 'do' instructions
        	    {
        	        string_literal35 = (pANTLR3_COMMON_TOKEN) MATCHT(49, &FOLLOW_49_in_instruction1041);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_49; stream_49->add(stream_49, string_literal35, NULL);


        	        ID36 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_instruction1043);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, ID36, NULL);


        	        string_literal37 = (pANTLR3_COMMON_TOKEN) MATCHT(37, &FOLLOW_37_in_instruction1045);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_37; stream_37->add(stream_37, string_literal37, NULL);


        	        FOLLOWPUSH(FOLLOW_value_in_instruction1049);
        	        v1=value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_value; stream_value->add(stream_value, v1.tree, NULL);

        	        string_literal38 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_instruction1051);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_56; stream_56->add(stream_56, string_literal38, NULL);


        	        FOLLOWPUSH(FOLLOW_value_in_instruction1055);
        	        v2=value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_value; stream_value->add(stream_value, v2.tree, NULL);

        	        string_literal39 = (pANTLR3_COMMON_TOKEN) MATCHT(46, &FOLLOW_46_in_instruction1057);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_46; stream_46->add(stream_46, string_literal39, NULL);


        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction1059);
        	        instructions40=instructions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, instructions40.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : v2, instructions, ID, v1
        	         * token labels      : 
        	         * rule labels       : v1, v2, retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_v1;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_v2;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_v1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token v1", v1.tree != NULL ? v1.tree : NULL);
        	        	stream_v2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token v2", v2.tree != NULL ? v2.tree : NULL);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 84:81: -> ^( FOR ID $v1 $v2 instructions )
        	        	{
        	        	    // Tiger.g:84:84: ^( FOR ID $v1 $v2 instructions )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FOR, (pANTLR3_UINT8)"FOR")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_ID == NULL ? NULL : stream_ID->nextNode(stream_ID)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_v1 == NULL ? NULL : stream_v1->nextTree(stream_v1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_v2 == NULL ? NULL : stream_v2->nextTree(stream_v2));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instructions == NULL ? NULL : stream_instructions->nextTree(stream_instructions));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_v1 != NULL) stream_v1->free(stream_v1);
        	        	if (stream_v2 != NULL) stream_v2->free(stream_v2);
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 6:
        	    // Tiger.g:85:5: 'break'
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        string_literal41 = (pANTLR3_COMMON_TOKEN) MATCHT(45, &FOLLOW_45_in_instruction1102);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        string_literal41_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal41));
        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal41_tree);


        	    }
        	    break;
        	case 7:
        	    // Tiger.g:87:5: value
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_value_in_instruction1109);
        	        value42=value(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, value42.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleinstructionEx; /* Prevent compiler warnings */
    ruleinstructionEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_55 != NULL) stream_55->free(stream_55);
        if (stream_56 != NULL) stream_56->free(stream_56);
        if (stream_46 != NULL) stream_46->free(stream_46);
        if (stream_47 != NULL) stream_47->free(stream_47);
        if (stream_58 != NULL) stream_58->free(stream_58);
        if (stream_48 != NULL) stream_48->free(stream_48);
        if (stream_37 != NULL) stream_37->free(stream_37);
        if (stream_49 != NULL) stream_49->free(stream_49);
        if (stream_ID != NULL) stream_ID->free(stream_ID);
        if (stream_51 != NULL) stream_51->free(stream_51);
        if (stream_52 != NULL) stream_52->free(stream_52);
        if (stream_53 != NULL) stream_53->free(stream_53);
        if (stream_instructions != NULL) stream_instructions->free(stream_instructions);
        if (stream_declararion != NULL) stream_declararion->free(stream_declararion);
        if (stream_value != NULL) stream_value->free(stream_value);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end instruction */

/**
 * $ANTLR start atom
 * Tiger.g:92:1: atom : ( ID |name= ID '(' (p1= ID ( ',' p2= ID )* )? ')' ';' -> ^( FUNC_CALL $name ( $p1 ( $p2)* )? ) | STRING | INTEGER | 'nil' );
 */
static TigerParser_atom_return
atom(pTigerParser ctx)
{
    TigerParser_atom_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    name;
    pANTLR3_COMMON_TOKEN    p1;
    pANTLR3_COMMON_TOKEN    p2;
    pANTLR3_COMMON_TOKEN    ID43;
    pANTLR3_COMMON_TOKEN    char_literal44;
    pANTLR3_COMMON_TOKEN    char_literal45;
    pANTLR3_COMMON_TOKEN    char_literal46;
    pANTLR3_COMMON_TOKEN    char_literal47;
    pANTLR3_COMMON_TOKEN    STRING48;
    pANTLR3_COMMON_TOKEN    INTEGER49;
    pANTLR3_COMMON_TOKEN    string_literal50;

    pANTLR3_BASE_TREE name_tree;
    pANTLR3_BASE_TREE p1_tree;
    pANTLR3_BASE_TREE p2_tree;
    pANTLR3_BASE_TREE ID43_tree;
    pANTLR3_BASE_TREE char_literal44_tree;
    pANTLR3_BASE_TREE char_literal45_tree;
    pANTLR3_BASE_TREE char_literal46_tree;
    pANTLR3_BASE_TREE char_literal47_tree;
    pANTLR3_BASE_TREE STRING48_tree;
    pANTLR3_BASE_TREE INTEGER49_tree;
    pANTLR3_BASE_TREE string_literal50_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_33;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_38;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_29;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_30;

    /* Initialize rule variables
     */

    root_0 = NULL;

    name       = NULL;
    p1       = NULL;
    p2       = NULL;
    ID43       = NULL;
    char_literal44       = NULL;
    char_literal45       = NULL;
    char_literal46       = NULL;
    char_literal47       = NULL;
    STRING48       = NULL;
    INTEGER49       = NULL;
    string_literal50       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    name_tree   = NULL;
    p1_tree   = NULL;
    p2_tree   = NULL;
    ID43_tree   = NULL;
    char_literal44_tree   = NULL;
    char_literal45_tree   = NULL;
    char_literal46_tree   = NULL;
    char_literal47_tree   = NULL;
    STRING48_tree   = NULL;
    INTEGER49_tree   = NULL;
    string_literal50_tree   = NULL;

    stream_33   = NULL;
    #define CREATE_stream_33  if (stream_33 == NULL) {stream_33 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 33"); } 
    stream_38   = NULL;
    #define CREATE_stream_38  if (stream_38 == NULL) {stream_38 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 38"); } 
    stream_29   = NULL;
    #define CREATE_stream_29  if (stream_29 == NULL) {stream_29 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 29"); } 
    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 
    stream_30   = NULL;
    #define CREATE_stream_30  if (stream_30 == NULL) {stream_30 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 30"); } 

    retval.tree  = NULL;

    {
        {
            //  Tiger.g:93:3: ( ID |name= ID '(' (p1= ID ( ',' p2= ID )* )? ')' ';' -> ^( FUNC_CALL $name ( $p1 ( $p2)* )? ) | STRING | INTEGER | 'nil' )

            ANTLR3_UINT32 alt14;

            alt14=5;

            switch ( LA(1) )
            {
            case ID:
            	{
            		switch ( LA(2) )
            		{
            		case 29:
            			{
            				switch ( LA(3) )
            				{
            				case ID:
            					{
            						switch ( LA(4) )
            						{
            						case 28:
            						case 29:
            						case 31:
            						case 32:
            						case 34:
            						case 35:
            						case 37:
            						case 38:
            						case 39:
            						case 40:
            						case 41:
            						case 42:
            						case 43:
            						case 44:
            						case 59:
            							{
            								alt14=1;
            							}
            						    break;
            						case 33:
            							{
            								alt14=2;
            							}
            						    break;
            						case 30:
            							{
            								switch ( LA(5) )
            								{
            								case 38:
            									{
            										alt14=2;
            									}
            								    break;
            								case ID:
            								case INTEGER:
            								case STRING:
            								case 29:
            								case 45:
            								case 48:
            								case 49:
            								case 51:
            								case 53:
            								case 54:
            								case 58:
            									{
            										alt14=1;
            									}
            								    break;

            								default:
            								    CONSTRUCTEX();
            								    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            								    EXCEPTION->message      = (void *)"";
            								    EXCEPTION->decisionNum  = 14;
            								    EXCEPTION->state        = 9;


            								    goto ruleatomEx;

            								}

            							}
            						    break;

            						default:
            						    CONSTRUCTEX();
            						    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            						    EXCEPTION->message      = (void *)"";
            						    EXCEPTION->decisionNum  = 14;
            						    EXCEPTION->state        = 7;


            						    goto ruleatomEx;

            						}

            					}
            				    break;
            				case 30:
            					{
            						alt14=2;
            					}
            				    break;
            				case INTEGER:
            				case STRING:
            				case 45:
            				case 49:
            				case 51:
            				case 53:
            				case 54:
            				case 58:
            					{
            						alt14=1;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 14;
            				    EXCEPTION->state        = 5;


            				    goto ruleatomEx;

            				}

            			}
            		    break;
            		case EOF:
            		case ID:
            		case INTEGER:
            		case STRING:
            		case 28:
            		case 30:
            		case 31:
            		case 32:
            		case 34:
            		case 35:
            		case 38:
            		case 39:
            		case 40:
            		case 41:
            		case 42:
            		case 43:
            		case 44:
            		case 45:
            		case 46:
            		case 47:
            		case 48:
            		case 49:
            		case 50:
            		case 51:
            		case 52:
            		case 53:
            		case 54:
            		case 55:
            		case 56:
            		case 57:
            		case 58:
            		case 59:
            			{
            				alt14=1;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 14;
            		    EXCEPTION->state        = 1;


            		    goto ruleatomEx;

            		}

            	}
                break;
            case STRING:
            	{
            		alt14=3;
            	}
                break;
            case INTEGER:
            	{
            		alt14=4;
            	}
                break;
            case 54:
            	{
            		alt14=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 14;
                EXCEPTION->state        = 0;


                goto ruleatomEx;

            }

            switch (alt14)
            {
        	case 1:
        	    // Tiger.g:93:5: ID
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        ID43 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_atom1124);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }

        	        ID43_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ID43));
        	        ADAPTOR->addChild(ADAPTOR, root_0, ID43_tree);


        	    }
        	    break;
        	case 2:
        	    // Tiger.g:95:5: name= ID '(' (p1= ID ( ',' p2= ID )* )? ')' ';'
        	    {
        	        name = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_atom1133);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, name, NULL);


        	        char_literal44 = (pANTLR3_COMMON_TOKEN) MATCHT(29, &FOLLOW_29_in_atom1135);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_29; stream_29->add(stream_29, char_literal44, NULL);


        	        // Tiger.g:95:17: (p1= ID ( ',' p2= ID )* )?
        	        {
        	            int alt13=2;
        	            switch ( LA(1) )
        	            {
        	                case ID:
        	                	{
        	                		alt13=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt13)
        	            {
        	        	case 1:
        	        	    // Tiger.g:95:18: p1= ID ( ',' p2= ID )*
        	        	    {
        	        	        p1 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_atom1140);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_ID; stream_ID->add(stream_ID, p1, NULL);


        	        	        // Tiger.g:95:24: ( ',' p2= ID )*

        	        	        for (;;)
        	        	        {
        	        	            int alt12=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case 33:
        	        	            	{
        	        	            		alt12=1;
        	        	            	}
        	        	                break;

        	        	            }

        	        	            switch (alt12)
        	        	            {
        	        	        	case 1:
        	        	        	    // Tiger.g:95:25: ',' p2= ID
        	        	        	    {
        	        	        	        char_literal45 = (pANTLR3_COMMON_TOKEN) MATCHT(33, &FOLLOW_33_in_atom1143);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleatomEx;
        	        	        	        }
        	        	        	         
        	        	        	        CREATE_stream_33; stream_33->add(stream_33, char_literal45, NULL);


        	        	        	        p2 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_atom1147);
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleatomEx;
        	        	        	        }
        	        	        	         
        	        	        	        CREATE_stream_ID; stream_ID->add(stream_ID, p2, NULL);


        	        	        	    }
        	        	        	    break;

        	        	        	default:
        	        	        	    goto loop12;	/* break out of the loop */
        	        	        	    break;
        	        	            }
        	        	        }
        	        	        loop12: ; /* Jump out to here if this rule does not match */


        	        	    }
        	        	    break;

        	            }
        	        }

        	        char_literal46 = (pANTLR3_COMMON_TOKEN) MATCHT(30, &FOLLOW_30_in_atom1153);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_30; stream_30->add(stream_30, char_literal46, NULL);


        	        char_literal47 = (pANTLR3_COMMON_TOKEN) MATCHT(38, &FOLLOW_38_in_atom1155);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_38; stream_38->add(stream_38, char_literal47, NULL);


        	        /* AST REWRITE
        	         * elements          : p1, name, p2
        	         * token labels      : p1, p2, name
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_p1;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_p2;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_name;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_p1=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token p1", p1);
        	        	stream_p2=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token p2", p2);
        	        	stream_name=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token name", name);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 95:81: -> ^( FUNC_CALL $name ( $p1 ( $p2)* )? )
        	        	{
        	        	    // Tiger.g:95:84: ^( FUNC_CALL $name ( $p1 ( $p2)* )? )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FUNC_CALL, (pANTLR3_UINT8)"FUNC_CALL")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_name == NULL ? NULL : stream_name->nextNode(stream_name));

        	        	        // Tiger.g:95:102: ( $p1 ( $p2)* )?
        	        	        {
        	        	        	if ( (stream_p1 != NULL && stream_p1->hasNext(stream_p1)) || (stream_p2 != NULL && stream_p2->hasNext(stream_p2))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_p1 == NULL ? NULL : stream_p1->nextNode(stream_p1));

        	        	        		// Tiger.g:95:108: ( $p2)*
        	        	        		{
        	        	        			while ( (stream_p2 != NULL && stream_p2->hasNext(stream_p2))  )
        	        	        			{
        	        	        				ADAPTOR->addChild(ADAPTOR, root_1, stream_p2 == NULL ? NULL : stream_p2->nextNode(stream_p2));

        	        	        			}
        	        	        			if (stream_p2 != NULL) stream_p2->reset(stream_p2);

        	        	        		}

        	        	        	}
        	        	        	if ( stream_p1 != NULL) stream_p1->reset(stream_p1);
        	        	        	if ( stream_p2 != NULL) stream_p2->reset(stream_p2);

        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_p1 != NULL) stream_p1->free(stream_p1); 
        	        	if (stream_p2 != NULL) stream_p2->free(stream_p2); 
        	        	if (stream_name != NULL) stream_name->free(stream_name); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 3:
        	    // Tiger.g:97:5: STRING
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        STRING48 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING, &FOLLOW_STRING_in_atom1215);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }

        	        STRING48_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, STRING48));
        	        ADAPTOR->addChild(ADAPTOR, root_0, STRING48_tree);


        	    }
        	    break;
        	case 4:
        	    // Tiger.g:98:5: INTEGER
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        INTEGER49 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER, &FOLLOW_INTEGER_in_atom1221);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }

        	        INTEGER49_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, INTEGER49));
        	        ADAPTOR->addChild(ADAPTOR, root_0, INTEGER49_tree);


        	    }
        	    break;
        	case 5:
        	    // Tiger.g:99:5: 'nil'
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        string_literal50 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_atom1227);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }

        	        string_literal50_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal50));
        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal50_tree);


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleatomEx; /* Prevent compiler warnings */
    ruleatomEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_33 != NULL) stream_33->free(stream_33);
        if (stream_38 != NULL) stream_38->free(stream_38);
        if (stream_29 != NULL) stream_29->free(stream_29);
        if (stream_ID != NULL) stream_ID->free(stream_ID);
        if (stream_30 != NULL) stream_30->free(stream_30);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end atom */

/**
 * $ANTLR start value
 * Tiger.g:104:1: value : or ;
 */
static TigerParser_value_return
value(pTigerParser ctx)
{
    TigerParser_value_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_or_return or51;
    #undef	RETURN_TYPE_or51
    #define	RETURN_TYPE_or51 TigerParser_or_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    or51.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Tiger.g:105:3: ( or )
        // Tiger.g:105:5: or
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_or_in_value1242);
            or51=or(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevalueEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, or51.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulevalueEx; /* Prevent compiler warnings */
    rulevalueEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end value */

/**
 * $ANTLR start or
 * Tiger.g:108:1: or : a1= and ( '|' a2= and )* -> ^( OR $a1 ( $a2)* ) ;
 */
static TigerParser_or_return
or(pTigerParser ctx)
{
    TigerParser_or_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal52;
    TigerParser_and_return a1;
    #undef	RETURN_TYPE_a1
    #define	RETURN_TYPE_a1 TigerParser_and_return

    TigerParser_and_return a2;
    #undef	RETURN_TYPE_a2
    #define	RETURN_TYPE_a2 TigerParser_and_return

    pANTLR3_BASE_TREE char_literal52_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_59;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_and;
    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal52       = NULL;
    a1.tree = NULL;

    a2.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal52_tree   = NULL;

    stream_59   = NULL;
    #define CREATE_stream_59  if (stream_59 == NULL) {stream_59 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 59"); } 
    stream_and   = NULL;
    #define CREATE_stream_and  if (stream_and == NULL) {stream_and = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule and"); }

    retval.tree  = NULL;

    {
        // Tiger.g:109:3: (a1= and ( '|' a2= and )* -> ^( OR $a1 ( $a2)* ) )
        // Tiger.g:109:5: a1= and ( '|' a2= and )*
        {
            FOLLOWPUSH(FOLLOW_and_in_or1257);
            a1=and(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleorEx;
            }

            CREATE_stream_and; stream_and->add(stream_and, a1.tree, NULL);

            // Tiger.g:109:12: ( '|' a2= and )*

            for (;;)
            {
                int alt15=2;
                switch ( LA(1) )
                {
                case 59:
                	{
                		alt15=1;
                	}
                    break;

                }

                switch (alt15)
                {
            	case 1:
            	    // Tiger.g:109:13: '|' a2= and
            	    {
            	        char_literal52 = (pANTLR3_COMMON_TOKEN) MATCHT(59, &FOLLOW_59_in_or1260);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleorEx;
            	        }
            	         
            	        CREATE_stream_59; stream_59->add(stream_59, char_literal52, NULL);


            	        FOLLOWPUSH(FOLLOW_and_in_or1264);
            	        a2=and(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleorEx;
            	        }

            	        CREATE_stream_and; stream_and->add(stream_and, a2.tree, NULL);

            	    }
            	    break;

            	default:
            	    goto loop15;	/* break out of the loop */
            	    break;
                }
            }
            loop15: ; /* Jump out to here if this rule does not match */


            /* AST REWRITE
             * elements          : a1, a2
             * token labels      : 
             * rule labels       : a1, a2, retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_a1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_a2;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_a1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token a1", a1.tree != NULL ? a1.tree : NULL);
            	stream_a2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token a2", a2.tree != NULL ? a2.tree : NULL);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 109:81: -> ^( OR $a1 ( $a2)* )
            	{
            	    // Tiger.g:109:84: ^( OR $a1 ( $a2)* )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, OR, (pANTLR3_UINT8)"OR")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_a1 == NULL ? NULL : stream_a1->nextTree(stream_a1));

            	        // Tiger.g:109:94: ( $a2)*
            	        {
            	        	while ( (stream_a2 != NULL && stream_a2->hasNext(stream_a2))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_a2 == NULL ? NULL : stream_a2->nextTree(stream_a2));

            	        	}
            	        	if (stream_a2 != NULL) stream_a2->reset(stream_a2);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_a1 != NULL) stream_a1->free(stream_a1);
            	if (stream_a2 != NULL) stream_a2->free(stream_a2);
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleorEx; /* Prevent compiler warnings */
    ruleorEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_59 != NULL) stream_59->free(stream_59);
        if (stream_and != NULL) stream_and->free(stream_and);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end or */

/**
 * $ANTLR start and
 * Tiger.g:112:1: and : c1= comparison ( '&' c2= comparison )* -> ^( AND $c1 ( $c2)* ) ;
 */
static TigerParser_and_return
and(pTigerParser ctx)
{
    TigerParser_and_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal53;
    TigerParser_comparison_return c1;
    #undef	RETURN_TYPE_c1
    #define	RETURN_TYPE_c1 TigerParser_comparison_return

    TigerParser_comparison_return c2;
    #undef	RETURN_TYPE_c2
    #define	RETURN_TYPE_c2 TigerParser_comparison_return

    pANTLR3_BASE_TREE char_literal53_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_28;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_comparison;
    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal53       = NULL;
    c1.tree = NULL;

    c2.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal53_tree   = NULL;

    stream_28   = NULL;
    #define CREATE_stream_28  if (stream_28 == NULL) {stream_28 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 28"); } 
    stream_comparison   = NULL;
    #define CREATE_stream_comparison  if (stream_comparison == NULL) {stream_comparison = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule comparison"); }

    retval.tree  = NULL;

    {
        // Tiger.g:113:3: (c1= comparison ( '&' c2= comparison )* -> ^( AND $c1 ( $c2)* ) )
        // Tiger.g:113:5: c1= comparison ( '&' c2= comparison )*
        {
            FOLLOWPUSH(FOLLOW_comparison_in_and1349);
            c1=comparison(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleandEx;
            }

            CREATE_stream_comparison; stream_comparison->add(stream_comparison, c1.tree, NULL);

            // Tiger.g:113:19: ( '&' c2= comparison )*

            for (;;)
            {
                int alt16=2;
                switch ( LA(1) )
                {
                case 28:
                	{
                		alt16=1;
                	}
                    break;

                }

                switch (alt16)
                {
            	case 1:
            	    // Tiger.g:113:20: '&' c2= comparison
            	    {
            	        char_literal53 = (pANTLR3_COMMON_TOKEN) MATCHT(28, &FOLLOW_28_in_and1352);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleandEx;
            	        }
            	         
            	        CREATE_stream_28; stream_28->add(stream_28, char_literal53, NULL);


            	        FOLLOWPUSH(FOLLOW_comparison_in_and1356);
            	        c2=comparison(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleandEx;
            	        }

            	        CREATE_stream_comparison; stream_comparison->add(stream_comparison, c2.tree, NULL);

            	    }
            	    break;

            	default:
            	    goto loop16;	/* break out of the loop */
            	    break;
                }
            }
            loop16: ; /* Jump out to here if this rule does not match */


            /* AST REWRITE
             * elements          : c1, c2
             * token labels      : 
             * rule labels       : c1, retval, c2
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_c1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_c2;

            	stream_c1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c1", c1.tree != NULL ? c1.tree : NULL);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);
            	stream_c2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token c2", c2.tree != NULL ? c2.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 113:81: -> ^( AND $c1 ( $c2)* )
            	{
            	    // Tiger.g:113:84: ^( AND $c1 ( $c2)* )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, AND, (pANTLR3_UINT8)"AND")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_c1 == NULL ? NULL : stream_c1->nextTree(stream_c1));

            	        // Tiger.g:113:95: ( $c2)*
            	        {
            	        	while ( (stream_c2 != NULL && stream_c2->hasNext(stream_c2))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_c2 == NULL ? NULL : stream_c2->nextTree(stream_c2));

            	        	}
            	        	if (stream_c2 != NULL) stream_c2->reset(stream_c2);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_c1 != NULL) stream_c1->free(stream_c1);
            	if (stream_retval != NULL) stream_retval->free(stream_retval);
            	if (stream_c2 != NULL) stream_c2->free(stream_c2);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleandEx; /* Prevent compiler warnings */
    ruleandEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_28 != NULL) stream_28->free(stream_28);
        if (stream_comparison != NULL) stream_comparison->free(stream_comparison);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end and */

/**
 * $ANTLR start comparison
 * Tiger.g:116:1: comparison : a1= addition ( ( '=' | '<>' | '<' | '>' | '<=' | '>=' ) a2= addition )? -> ^( COMP $a1 ( $a2)* ) ;
 */
static TigerParser_comparison_return
comparison(pTigerParser ctx)
{
    TigerParser_comparison_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal54;
    pANTLR3_COMMON_TOKEN    string_literal55;
    pANTLR3_COMMON_TOKEN    char_literal56;
    pANTLR3_COMMON_TOKEN    char_literal57;
    pANTLR3_COMMON_TOKEN    string_literal58;
    pANTLR3_COMMON_TOKEN    string_literal59;
    TigerParser_addition_return a1;
    #undef	RETURN_TYPE_a1
    #define	RETURN_TYPE_a1 TigerParser_addition_return

    TigerParser_addition_return a2;
    #undef	RETURN_TYPE_a2
    #define	RETURN_TYPE_a2 TigerParser_addition_return

    pANTLR3_BASE_TREE char_literal54_tree;
    pANTLR3_BASE_TREE string_literal55_tree;
    pANTLR3_BASE_TREE char_literal56_tree;
    pANTLR3_BASE_TREE char_literal57_tree;
    pANTLR3_BASE_TREE string_literal58_tree;
    pANTLR3_BASE_TREE string_literal59_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_44;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_39;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_40;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_41;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_42;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_43;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_addition;
    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal54       = NULL;
    string_literal55       = NULL;
    char_literal56       = NULL;
    char_literal57       = NULL;
    string_literal58       = NULL;
    string_literal59       = NULL;
    a1.tree = NULL;

    a2.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal54_tree   = NULL;
    string_literal55_tree   = NULL;
    char_literal56_tree   = NULL;
    char_literal57_tree   = NULL;
    string_literal58_tree   = NULL;
    string_literal59_tree   = NULL;

    stream_44   = NULL;
    #define CREATE_stream_44  if (stream_44 == NULL) {stream_44 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 44"); } 
    stream_39   = NULL;
    #define CREATE_stream_39  if (stream_39 == NULL) {stream_39 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 39"); } 
    stream_40   = NULL;
    #define CREATE_stream_40  if (stream_40 == NULL) {stream_40 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 40"); } 
    stream_41   = NULL;
    #define CREATE_stream_41  if (stream_41 == NULL) {stream_41 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 41"); } 
    stream_42   = NULL;
    #define CREATE_stream_42  if (stream_42 == NULL) {stream_42 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 42"); } 
    stream_43   = NULL;
    #define CREATE_stream_43  if (stream_43 == NULL) {stream_43 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 43"); } 
    stream_addition   = NULL;
    #define CREATE_stream_addition  if (stream_addition == NULL) {stream_addition = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule addition"); }

    retval.tree  = NULL;

    {
        // Tiger.g:117:3: (a1= addition ( ( '=' | '<>' | '<' | '>' | '<=' | '>=' ) a2= addition )? -> ^( COMP $a1 ( $a2)* ) )
        // Tiger.g:117:5: a1= addition ( ( '=' | '<>' | '<' | '>' | '<=' | '>=' ) a2= addition )?
        {
            FOLLOWPUSH(FOLLOW_addition_in_comparison1427);
            a1=addition(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecomparisonEx;
            }

            CREATE_stream_addition; stream_addition->add(stream_addition, a1.tree, NULL);

            // Tiger.g:117:17: ( ( '=' | '<>' | '<' | '>' | '<=' | '>=' ) a2= addition )?
            {
                int alt18=2;
                switch ( LA(1) )
                {
                    case 39:
                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    	{
                    		alt18=1;
                    	}
                        break;
                }

                switch (alt18)
                {
            	case 1:
            	    // Tiger.g:117:18: ( '=' | '<>' | '<' | '>' | '<=' | '>=' ) a2= addition
            	    {
            	        // Tiger.g:117:18: ( '=' | '<>' | '<' | '>' | '<=' | '>=' )
            	        {
            	            int alt17=6;
            	            switch ( LA(1) )
            	            {
            	            case 42:
            	            	{
            	            		alt17=1;
            	            	}
            	                break;
            	            case 41:
            	            	{
            	            		alt17=2;
            	            	}
            	                break;
            	            case 39:
            	            	{
            	            		alt17=3;
            	            	}
            	                break;
            	            case 43:
            	            	{
            	            		alt17=4;
            	            	}
            	                break;
            	            case 40:
            	            	{
            	            		alt17=5;
            	            	}
            	                break;
            	            case 44:
            	            	{
            	            		alt17=6;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 17;
            	                EXCEPTION->state        = 0;


            	                goto rulecomparisonEx;

            	            }

            	            switch (alt17)
            	            {
            	        	case 1:
            	        	    // Tiger.g:117:19: '='
            	        	    {
            	        	        char_literal54 = (pANTLR3_COMMON_TOKEN) MATCHT(42, &FOLLOW_42_in_comparison1431);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulecomparisonEx;
            	        	        }
            	        	         
            	        	        CREATE_stream_42; stream_42->add(stream_42, char_literal54, NULL);


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Tiger.g:117:23: '<>'
            	        	    {
            	        	        string_literal55 = (pANTLR3_COMMON_TOKEN) MATCHT(41, &FOLLOW_41_in_comparison1433);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulecomparisonEx;
            	        	        }
            	        	         
            	        	        CREATE_stream_41; stream_41->add(stream_41, string_literal55, NULL);


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // Tiger.g:117:28: '<'
            	        	    {
            	        	        char_literal56 = (pANTLR3_COMMON_TOKEN) MATCHT(39, &FOLLOW_39_in_comparison1435);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulecomparisonEx;
            	        	        }
            	        	         
            	        	        CREATE_stream_39; stream_39->add(stream_39, char_literal56, NULL);


            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // Tiger.g:117:32: '>'
            	        	    {
            	        	        char_literal57 = (pANTLR3_COMMON_TOKEN) MATCHT(43, &FOLLOW_43_in_comparison1437);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulecomparisonEx;
            	        	        }
            	        	         
            	        	        CREATE_stream_43; stream_43->add(stream_43, char_literal57, NULL);


            	        	    }
            	        	    break;
            	        	case 5:
            	        	    // Tiger.g:117:36: '<='
            	        	    {
            	        	        string_literal58 = (pANTLR3_COMMON_TOKEN) MATCHT(40, &FOLLOW_40_in_comparison1439);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulecomparisonEx;
            	        	        }
            	        	         
            	        	        CREATE_stream_40; stream_40->add(stream_40, string_literal58, NULL);


            	        	    }
            	        	    break;
            	        	case 6:
            	        	    // Tiger.g:117:41: '>='
            	        	    {
            	        	        string_literal59 = (pANTLR3_COMMON_TOKEN) MATCHT(44, &FOLLOW_44_in_comparison1441);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulecomparisonEx;
            	        	        }
            	        	         
            	        	        CREATE_stream_44; stream_44->add(stream_44, string_literal59, NULL);


            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_addition_in_comparison1446);
            	        a2=addition(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecomparisonEx;
            	        }

            	        CREATE_stream_addition; stream_addition->add(stream_addition, a2.tree, NULL);

            	    }
            	    break;

                }
            }

            /* AST REWRITE
             * elements          : a1, a2
             * token labels      : 
             * rule labels       : a1, a2, retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_a1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_a2;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_a1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token a1", a1.tree != NULL ? a1.tree : NULL);
            	stream_a2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token a2", a2.tree != NULL ? a2.tree : NULL);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 117:81: -> ^( COMP $a1 ( $a2)* )
            	{
            	    // Tiger.g:117:84: ^( COMP $a1 ( $a2)* )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMP, (pANTLR3_UINT8)"COMP")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_a1 == NULL ? NULL : stream_a1->nextTree(stream_a1));

            	        // Tiger.g:117:96: ( $a2)*
            	        {
            	        	while ( (stream_a2 != NULL && stream_a2->hasNext(stream_a2))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_a2 == NULL ? NULL : stream_a2->nextTree(stream_a2));

            	        	}
            	        	if (stream_a2 != NULL) stream_a2->reset(stream_a2);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_a1 != NULL) stream_a1->free(stream_a1);
            	if (stream_a2 != NULL) stream_a2->free(stream_a2);
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulecomparisonEx; /* Prevent compiler warnings */
    rulecomparisonEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_44 != NULL) stream_44->free(stream_44);
        if (stream_39 != NULL) stream_39->free(stream_39);
        if (stream_40 != NULL) stream_40->free(stream_40);
        if (stream_41 != NULL) stream_41->free(stream_41);
        if (stream_42 != NULL) stream_42->free(stream_42);
        if (stream_43 != NULL) stream_43->free(stream_43);
        if (stream_addition != NULL) stream_addition->free(stream_addition);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end comparison */

/**
 * $ANTLR start addition
 * Tiger.g:120:1: addition : m1= multiplication ( ( '+' | '-' ) m2= multiplication )* -> ^( ADD $m1 ( $m2)* ) ;
 */
static TigerParser_addition_return
addition(pTigerParser ctx)
{
    TigerParser_addition_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal60;
    pANTLR3_COMMON_TOKEN    char_literal61;
    TigerParser_multiplication_return m1;
    #undef	RETURN_TYPE_m1
    #define	RETURN_TYPE_m1 TigerParser_multiplication_return

    TigerParser_multiplication_return m2;
    #undef	RETURN_TYPE_m2
    #define	RETURN_TYPE_m2 TigerParser_multiplication_return

    pANTLR3_BASE_TREE char_literal60_tree;
    pANTLR3_BASE_TREE char_literal61_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_34;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_32;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_multiplication;
    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal60       = NULL;
    char_literal61       = NULL;
    m1.tree = NULL;

    m2.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal60_tree   = NULL;
    char_literal61_tree   = NULL;

    stream_34   = NULL;
    #define CREATE_stream_34  if (stream_34 == NULL) {stream_34 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 34"); } 
    stream_32   = NULL;
    #define CREATE_stream_32  if (stream_32 == NULL) {stream_32 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 32"); } 
    stream_multiplication   = NULL;
    #define CREATE_stream_multiplication  if (stream_multiplication == NULL) {stream_multiplication = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule multiplication"); }

    retval.tree  = NULL;

    {
        // Tiger.g:121:3: (m1= multiplication ( ( '+' | '-' ) m2= multiplication )* -> ^( ADD $m1 ( $m2)* ) )
        // Tiger.g:121:5: m1= multiplication ( ( '+' | '-' ) m2= multiplication )*
        {
            FOLLOWPUSH(FOLLOW_multiplication_in_addition1496);
            m1=multiplication(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleadditionEx;
            }

            CREATE_stream_multiplication; stream_multiplication->add(stream_multiplication, m1.tree, NULL);

            // Tiger.g:121:23: ( ( '+' | '-' ) m2= multiplication )*

            for (;;)
            {
                int alt20=2;
                switch ( LA(1) )
                {
                case 32:
                case 34:
                	{
                		alt20=1;
                	}
                    break;

                }

                switch (alt20)
                {
            	case 1:
            	    // Tiger.g:121:24: ( '+' | '-' ) m2= multiplication
            	    {
            	        // Tiger.g:121:24: ( '+' | '-' )
            	        {
            	            int alt19=2;
            	            switch ( LA(1) )
            	            {
            	            case 32:
            	            	{
            	            		alt19=1;
            	            	}
            	                break;
            	            case 34:
            	            	{
            	            		alt19=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 19;
            	                EXCEPTION->state        = 0;


            	                goto ruleadditionEx;

            	            }

            	            switch (alt19)
            	            {
            	        	case 1:
            	        	    // Tiger.g:121:25: '+'
            	        	    {
            	        	        char_literal60 = (pANTLR3_COMMON_TOKEN) MATCHT(32, &FOLLOW_32_in_addition1500);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleadditionEx;
            	        	        }
            	        	         
            	        	        CREATE_stream_32; stream_32->add(stream_32, char_literal60, NULL);


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Tiger.g:121:29: '-'
            	        	    {
            	        	        char_literal61 = (pANTLR3_COMMON_TOKEN) MATCHT(34, &FOLLOW_34_in_addition1502);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleadditionEx;
            	        	        }
            	        	         
            	        	        CREATE_stream_34; stream_34->add(stream_34, char_literal61, NULL);


            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_multiplication_in_addition1507);
            	        m2=multiplication(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadditionEx;
            	        }

            	        CREATE_stream_multiplication; stream_multiplication->add(stream_multiplication, m2.tree, NULL);

            	    }
            	    break;

            	default:
            	    goto loop20;	/* break out of the loop */
            	    break;
                }
            }
            loop20: ; /* Jump out to here if this rule does not match */


            /* AST REWRITE
             * elements          : m1, m2
             * token labels      : 
             * rule labels       : m1, m2, retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_m1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_m2;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_m1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token m1", m1.tree != NULL ? m1.tree : NULL);
            	stream_m2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token m2", m2.tree != NULL ? m2.tree : NULL);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 121:81: -> ^( ADD $m1 ( $m2)* )
            	{
            	    // Tiger.g:121:84: ^( ADD $m1 ( $m2)* )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ADD, (pANTLR3_UINT8)"ADD")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_m1 == NULL ? NULL : stream_m1->nextTree(stream_m1));

            	        // Tiger.g:121:95: ( $m2)*
            	        {
            	        	while ( (stream_m2 != NULL && stream_m2->hasNext(stream_m2))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_m2 == NULL ? NULL : stream_m2->nextTree(stream_m2));

            	        	}
            	        	if (stream_m2 != NULL) stream_m2->reset(stream_m2);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_m1 != NULL) stream_m1->free(stream_m1);
            	if (stream_m2 != NULL) stream_m2->free(stream_m2);
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleadditionEx; /* Prevent compiler warnings */
    ruleadditionEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_34 != NULL) stream_34->free(stream_34);
        if (stream_32 != NULL) stream_32->free(stream_32);
        if (stream_multiplication != NULL) stream_multiplication->free(stream_multiplication);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end addition */

/**
 * $ANTLR start multiplication
 * Tiger.g:123:1: multiplication : a1= atom ( ( '*' | '/' ) a2= atom )* -> ^( MULT $a1 ( $a2)* ) ;
 */
static TigerParser_multiplication_return
multiplication(pTigerParser ctx)
{
    TigerParser_multiplication_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal62;
    pANTLR3_COMMON_TOKEN    char_literal63;
    TigerParser_atom_return a1;
    #undef	RETURN_TYPE_a1
    #define	RETURN_TYPE_a1 TigerParser_atom_return

    TigerParser_atom_return a2;
    #undef	RETURN_TYPE_a2
    #define	RETURN_TYPE_a2 TigerParser_atom_return

    pANTLR3_BASE_TREE char_literal62_tree;
    pANTLR3_BASE_TREE char_literal63_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_35;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_31;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_atom;
    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal62       = NULL;
    char_literal63       = NULL;
    a1.tree = NULL;

    a2.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal62_tree   = NULL;
    char_literal63_tree   = NULL;

    stream_35   = NULL;
    #define CREATE_stream_35  if (stream_35 == NULL) {stream_35 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 35"); } 
    stream_31   = NULL;
    #define CREATE_stream_31  if (stream_31 == NULL) {stream_31 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 31"); } 
    stream_atom   = NULL;
    #define CREATE_stream_atom  if (stream_atom == NULL) {stream_atom = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule atom"); }

    retval.tree  = NULL;

    {
        // Tiger.g:124:3: (a1= atom ( ( '*' | '/' ) a2= atom )* -> ^( MULT $a1 ( $a2)* ) )
        // Tiger.g:124:5: a1= atom ( ( '*' | '/' ) a2= atom )*
        {
            FOLLOWPUSH(FOLLOW_atom_in_multiplication1563);
            a1=atom(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemultiplicationEx;
            }

            CREATE_stream_atom; stream_atom->add(stream_atom, a1.tree, NULL);

            // Tiger.g:124:13: ( ( '*' | '/' ) a2= atom )*

            for (;;)
            {
                int alt22=2;
                switch ( LA(1) )
                {
                case 31:
                case 35:
                	{
                		alt22=1;
                	}
                    break;

                }

                switch (alt22)
                {
            	case 1:
            	    // Tiger.g:124:14: ( '*' | '/' ) a2= atom
            	    {
            	        // Tiger.g:124:14: ( '*' | '/' )
            	        {
            	            int alt21=2;
            	            switch ( LA(1) )
            	            {
            	            case 31:
            	            	{
            	            		alt21=1;
            	            	}
            	                break;
            	            case 35:
            	            	{
            	            		alt21=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 21;
            	                EXCEPTION->state        = 0;


            	                goto rulemultiplicationEx;

            	            }

            	            switch (alt21)
            	            {
            	        	case 1:
            	        	    // Tiger.g:124:15: '*'
            	        	    {
            	        	        char_literal62 = (pANTLR3_COMMON_TOKEN) MATCHT(31, &FOLLOW_31_in_multiplication1567);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulemultiplicationEx;
            	        	        }
            	        	         
            	        	        CREATE_stream_31; stream_31->add(stream_31, char_literal62, NULL);


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Tiger.g:124:19: '/'
            	        	    {
            	        	        char_literal63 = (pANTLR3_COMMON_TOKEN) MATCHT(35, &FOLLOW_35_in_multiplication1569);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulemultiplicationEx;
            	        	        }
            	        	         
            	        	        CREATE_stream_35; stream_35->add(stream_35, char_literal63, NULL);


            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_atom_in_multiplication1574);
            	        a2=atom(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemultiplicationEx;
            	        }

            	        CREATE_stream_atom; stream_atom->add(stream_atom, a2.tree, NULL);

            	    }
            	    break;

            	default:
            	    goto loop22;	/* break out of the loop */
            	    break;
                }
            }
            loop22: ; /* Jump out to here if this rule does not match */


            /* AST REWRITE
             * elements          : a1, a2
             * token labels      : 
             * rule labels       : a1, a2, retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_a1;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_a2;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_a1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token a1", a1.tree != NULL ? a1.tree : NULL);
            	stream_a2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token a2", a2.tree != NULL ? a2.tree : NULL);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 124:81: -> ^( MULT $a1 ( $a2)* )
            	{
            	    // Tiger.g:124:84: ^( MULT $a1 ( $a2)* )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, MULT, (pANTLR3_UINT8)"MULT")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_a1 == NULL ? NULL : stream_a1->nextTree(stream_a1));

            	        // Tiger.g:124:96: ( $a2)*
            	        {
            	        	while ( (stream_a2 != NULL && stream_a2->hasNext(stream_a2))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_a2 == NULL ? NULL : stream_a2->nextTree(stream_a2));

            	        	}
            	        	if (stream_a2 != NULL) stream_a2->reset(stream_a2);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_a1 != NULL) stream_a1->free(stream_a1);
            	if (stream_a2 != NULL) stream_a2->free(stream_a2);
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulemultiplicationEx; /* Prevent compiler warnings */
    rulemultiplicationEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_35 != NULL) stream_35->free(stream_35);
        if (stream_31 != NULL) stream_31->free(stream_31);
        if (stream_atom != NULL) stream_atom->free(stream_atom);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end multiplication */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
