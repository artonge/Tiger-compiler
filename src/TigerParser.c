/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : ./src/Tiger.g
 *     -                            On : 2016-04-25 20:26:39
 *     -                for the parser : TigerParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "TigerParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pTigerParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pTigerParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pTigerParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pTigerParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   TigerParserTokenNames[63+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ADD",
        (pANTLR3_UINT8) "AND",
        (pANTLR3_UINT8) "ARGS",
        (pANTLR3_UINT8) "ASSIGNE",
        (pANTLR3_UINT8) "BREAK",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "COMP",
        (pANTLR3_UINT8) "DECLARATIONS",
        (pANTLR3_UINT8) "EXPR",
        (pANTLR3_UINT8) "FOR",
        (pANTLR3_UINT8) "FUNC_DECLARATION",
        (pANTLR3_UINT8) "ID",
        (pANTLR3_UINT8) "IF",
        (pANTLR3_UINT8) "INSTRUCTIONS",
        (pANTLR3_UINT8) "INT",
        (pANTLR3_UINT8) "INTEGER",
        (pANTLR3_UINT8) "LET",
        (pANTLR3_UINT8) "LETTER",
        (pANTLR3_UINT8) "MULT",
        (pANTLR3_UINT8) "NEG",
        (pANTLR3_UINT8) "NIL",
        (pANTLR3_UINT8) "OR",
        (pANTLR3_UINT8) "PARAM",
        (pANTLR3_UINT8) "PARAMS",
        (pANTLR3_UINT8) "RETURN",
        (pANTLR3_UINT8) "STR",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "VAR_DECLARATION",
        (pANTLR3_UINT8) "WHILE",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "'&'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'/'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "':='",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'<='",
        (pANTLR3_UINT8) "'<>'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'>='",
        (pANTLR3_UINT8) "'break'",
        (pANTLR3_UINT8) "'do'",
        (pANTLR3_UINT8) "'else'",
        (pANTLR3_UINT8) "'end'",
        (pANTLR3_UINT8) "'for'",
        (pANTLR3_UINT8) "'function'",
        (pANTLR3_UINT8) "'if'",
        (pANTLR3_UINT8) "'in'",
        (pANTLR3_UINT8) "'let'",
        (pANTLR3_UINT8) "'nil'",
        (pANTLR3_UINT8) "'return'",
        (pANTLR3_UINT8) "'then'",
        (pANTLR3_UINT8) "'to'",
        (pANTLR3_UINT8) "'var'",
        (pANTLR3_UINT8) "'while'",
        (pANTLR3_UINT8) "'|'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 TigerParser_program_return
	program    (pTigerParser ctx);
static 
 TigerParser_instructions_return
	instructions    (pTigerParser ctx);
static 
 TigerParser_declaration_return
	declaration    (pTigerParser ctx);
static 
 TigerParser_params_return
	params    (pTigerParser ctx);
static 
 TigerParser_param_return
	param    (pTigerParser ctx);
static 
 TigerParser_instruction_return
	instruction    (pTigerParser ctx);
static 
 TigerParser_atom_return
	atom    (pTigerParser ctx);
static 
 TigerParser_expr_return
	expr    (pTigerParser ctx);
static 
 TigerParser_assignExpr_return
	assignExpr    (pTigerParser ctx);
static 
 TigerParser_logExpr_return
	logExpr    (pTigerParser ctx);
static 
 TigerParser_andExpr_return
	andExpr    (pTigerParser ctx);
static 
 TigerParser_compExpr_return
	compExpr    (pTigerParser ctx);
static 
 TigerParser_addMinExpr_return
	addMinExpr    (pTigerParser ctx);
static 
 TigerParser_multDivExpr_return
	multDivExpr    (pTigerParser ctx);
static 
 TigerParser_addMin_return
	addMin    (pTigerParser ctx);
static 
 TigerParser_multDiv_return
	multDiv    (pTigerParser ctx);
static 
 TigerParser_comp_return
	comp    (pTigerParser ctx);
static 
 TigerParser_and_return
	and    (pTigerParser ctx);
static 
 TigerParser_or_return
	or    (pTigerParser ctx);
static 
 TigerParser_assign_return
	assign    (pTigerParser ctx);
static void	TigerParserFree(pTigerParser ctx);
static void     TigerParserReset (pTigerParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "./src/Tiger.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new TigerParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pTigerParser
TigerParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return TigerParserNewSSD(instream, NULL);
}

/** \brief Create a new TigerParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pTigerParser
TigerParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pTigerParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pTigerParser) ANTLR3_CALLOC(1, sizeof(TigerParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in TigerParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our TigerParser interface
     */
    ctx->program	= program;
    ctx->instructions	= instructions;
    ctx->declaration	= declaration;
    ctx->params	= params;
    ctx->param	= param;
    ctx->instruction	= instruction;
    ctx->atom	= atom;
    ctx->expr	= expr;
    ctx->assignExpr	= assignExpr;
    ctx->logExpr	= logExpr;
    ctx->andExpr	= andExpr;
    ctx->compExpr	= compExpr;
    ctx->addMinExpr	= addMinExpr;
    ctx->multDivExpr	= multDivExpr;
    ctx->addMin	= addMin;
    ctx->multDiv	= multDiv;
    ctx->comp	= comp;
    ctx->and	= and;
    ctx->or	= or;
    ctx->assign	= assign;
    ctx->free			= TigerParserFree;
    ctx->reset			= TigerParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);

ctx->vectors	= antlr3VectorFactoryNew(0);
    /* Install the token table
     */
    PSRSTATE->tokenNames   = TigerParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
TigerParserReset (pTigerParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 TigerParserFree(pTigerParser ctx)
 {
    /* Free any scope memory
     */

ctx->vectors->close(ctx->vectors);
/* We created the adaptor so we must free it
 */
ADAPTOR->free(ADAPTOR);
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return TigerParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_program252  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_program252_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_program252	= { FOLLOW_instructions_in_program252_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instruction_in_instructions263  */
static	ANTLR3_BITWORD FOLLOW_instruction_in_instructions263_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instruction_in_instructions263	= { FOLLOW_instruction_in_instructions263_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_64_in_declaration350  */
static	ANTLR3_BITWORD FOLLOW_64_in_declaration350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_64_in_declaration350	= { FOLLOW_64_in_declaration350_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_declaration354  */
static	ANTLR3_BITWORD FOLLOW_ID_in_declaration354_bits[]	= { ANTLR3_UINT64_LIT(0x00000C0000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_declaration354	= { FOLLOW_ID_in_declaration354_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_declaration357  */
static	ANTLR3_BITWORD FOLLOW_42_in_declaration357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_declaration357	= { FOLLOW_42_in_declaration357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_declaration361  */
static	ANTLR3_BITWORD FOLLOW_ID_in_declaration361_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_declaration361	= { FOLLOW_ID_in_declaration361_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_declaration365  */
static	ANTLR3_BITWORD FOLLOW_43_in_declaration365_bits[]	= { ANTLR3_UINT64_LIT(0x1000010840088000) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_declaration365	= { FOLLOW_43_in_declaration365_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_declaration367  */
static	ANTLR3_BITWORD FOLLOW_expr_in_declaration367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_declaration367	= { FOLLOW_expr_in_declaration367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_declaration425  */
static	ANTLR3_BITWORD FOLLOW_56_in_declaration425_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_56_in_declaration425	= { FOLLOW_56_in_declaration425_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_declaration429  */
static	ANTLR3_BITWORD FOLLOW_ID_in_declaration429_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_declaration429	= { FOLLOW_ID_in_declaration429_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_params_in_declaration431  */
static	ANTLR3_BITWORD FOLLOW_params_in_declaration431_bits[]	= { ANTLR3_UINT64_LIT(0x0001040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_params_in_declaration431	= { FOLLOW_params_in_declaration431_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_declaration434  */
static	ANTLR3_BITWORD FOLLOW_42_in_declaration434_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_declaration434	= { FOLLOW_42_in_declaration434_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_declaration438  */
static	ANTLR3_BITWORD FOLLOW_ID_in_declaration438_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_declaration438	= { FOLLOW_ID_in_declaration438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_48_in_declaration442  */
static	ANTLR3_BITWORD FOLLOW_48_in_declaration442_bits[]	= { ANTLR3_UINT64_LIT(0x3A88010840088000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_48_in_declaration442	= { FOLLOW_48_in_declaration442_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_declaration444  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_declaration444_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_declaration444	= { FOLLOW_instructions_in_declaration444_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_params485  */
static	ANTLR3_BITWORD FOLLOW_35_in_params485_bits[]	= { ANTLR3_UINT64_LIT(0x0000001000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_params485	= { FOLLOW_35_in_params485_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_in_params489  */
static	ANTLR3_BITWORD FOLLOW_param_in_params489_bits[]	= { ANTLR3_UINT64_LIT(0x0000009000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_param_in_params489	= { FOLLOW_param_in_params489_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_params492  */
static	ANTLR3_BITWORD FOLLOW_39_in_params492_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_params492	= { FOLLOW_39_in_params492_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_in_params494  */
static	ANTLR3_BITWORD FOLLOW_param_in_params494_bits[]	= { ANTLR3_UINT64_LIT(0x0000009000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_param_in_params494	= { FOLLOW_param_in_params494_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_params500  */
static	ANTLR3_BITWORD FOLLOW_36_in_params500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_params500	= { FOLLOW_36_in_params500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_param568  */
static	ANTLR3_BITWORD FOLLOW_ID_in_param568_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_param568	= { FOLLOW_ID_in_param568_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_param570  */
static	ANTLR3_BITWORD FOLLOW_42_in_param570_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_param570	= { FOLLOW_42_in_param570_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_param574  */
static	ANTLR3_BITWORD FOLLOW_ID_in_param574_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_param574	= { FOLLOW_ID_in_param574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_59_in_instruction657  */
static	ANTLR3_BITWORD FOLLOW_59_in_instruction657_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_59_in_instruction657	= { FOLLOW_59_in_instruction657_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_in_instruction659  */
static	ANTLR3_BITWORD FOLLOW_declaration_in_instruction659_bits[]	= { ANTLR3_UINT64_LIT(0x0500000000000000), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_in_instruction659	= { FOLLOW_declaration_in_instruction659_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_58_in_instruction662  */
static	ANTLR3_BITWORD FOLLOW_58_in_instruction662_bits[]	= { ANTLR3_UINT64_LIT(0x3A88010840088000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_58_in_instruction662	= { FOLLOW_58_in_instruction662_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction664  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction664_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction664	= { FOLLOW_instructions_in_instruction664_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_instruction666  */
static	ANTLR3_BITWORD FOLLOW_54_in_instruction666_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_54_in_instruction666	= { FOLLOW_54_in_instruction666_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_instruction721  */
static	ANTLR3_BITWORD FOLLOW_expr_in_instruction721_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_instruction721	= { FOLLOW_expr_in_instruction721_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_57_in_instruction728  */
static	ANTLR3_BITWORD FOLLOW_57_in_instruction728_bits[]	= { ANTLR3_UINT64_LIT(0x1000010840088000) };
static  ANTLR3_BITSET_LIST FOLLOW_57_in_instruction728	= { FOLLOW_57_in_instruction728_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_instruction730  */
static	ANTLR3_BITWORD FOLLOW_expr_in_instruction730_bits[]	= { ANTLR3_UINT64_LIT(0x4000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_instruction730	= { FOLLOW_expr_in_instruction730_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_62_in_instruction732  */
static	ANTLR3_BITWORD FOLLOW_62_in_instruction732_bits[]	= { ANTLR3_UINT64_LIT(0x3A88010840088000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_62_in_instruction732	= { FOLLOW_62_in_instruction732_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction736  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction736_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction736	= { FOLLOW_instructions_in_instruction736_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_53_in_instruction752  */
static	ANTLR3_BITWORD FOLLOW_53_in_instruction752_bits[]	= { ANTLR3_UINT64_LIT(0x3A88010840088000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_53_in_instruction752	= { FOLLOW_53_in_instruction752_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction756  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction756_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction756	= { FOLLOW_instructions_in_instruction756_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_65_in_instruction804  */
static	ANTLR3_BITWORD FOLLOW_65_in_instruction804_bits[]	= { ANTLR3_UINT64_LIT(0x1000010840088000) };
static  ANTLR3_BITSET_LIST FOLLOW_65_in_instruction804	= { FOLLOW_65_in_instruction804_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_instruction806  */
static	ANTLR3_BITWORD FOLLOW_expr_in_instruction806_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_instruction806	= { FOLLOW_expr_in_instruction806_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_52_in_instruction808  */
static	ANTLR3_BITWORD FOLLOW_52_in_instruction808_bits[]	= { ANTLR3_UINT64_LIT(0x3A88010840088000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_52_in_instruction808	= { FOLLOW_52_in_instruction808_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction810  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction810_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction810	= { FOLLOW_instructions_in_instruction810_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_55_in_instruction871  */
static	ANTLR3_BITWORD FOLLOW_55_in_instruction871_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_55_in_instruction871	= { FOLLOW_55_in_instruction871_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_instruction873  */
static	ANTLR3_BITWORD FOLLOW_ID_in_instruction873_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_instruction873	= { FOLLOW_ID_in_instruction873_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_instruction875  */
static	ANTLR3_BITWORD FOLLOW_43_in_instruction875_bits[]	= { ANTLR3_UINT64_LIT(0x1000010840088000) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_instruction875	= { FOLLOW_43_in_instruction875_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_instruction879  */
static	ANTLR3_BITWORD FOLLOW_expr_in_instruction879_bits[]	= { ANTLR3_UINT64_LIT(0x8000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_instruction879	= { FOLLOW_expr_in_instruction879_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_63_in_instruction881  */
static	ANTLR3_BITWORD FOLLOW_63_in_instruction881_bits[]	= { ANTLR3_UINT64_LIT(0x1000010840088000) };
static  ANTLR3_BITSET_LIST FOLLOW_63_in_instruction881	= { FOLLOW_63_in_instruction881_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_instruction885  */
static	ANTLR3_BITWORD FOLLOW_expr_in_instruction885_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_instruction885	= { FOLLOW_expr_in_instruction885_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_52_in_instruction887  */
static	ANTLR3_BITWORD FOLLOW_52_in_instruction887_bits[]	= { ANTLR3_UINT64_LIT(0x3A88010840088000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_52_in_instruction887	= { FOLLOW_52_in_instruction887_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction889  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction889_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction889	= { FOLLOW_instructions_in_instruction889_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_51_in_instruction934  */
static	ANTLR3_BITWORD FOLLOW_51_in_instruction934_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_51_in_instruction934	= { FOLLOW_51_in_instruction934_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_61_in_instruction1012  */
static	ANTLR3_BITWORD FOLLOW_61_in_instruction1012_bits[]	= { ANTLR3_UINT64_LIT(0x1000010840088000) };
static  ANTLR3_BITSET_LIST FOLLOW_61_in_instruction1012	= { FOLLOW_61_in_instruction1012_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_instruction1014  */
static	ANTLR3_BITWORD FOLLOW_expr_in_instruction1014_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_instruction1014	= { FOLLOW_expr_in_instruction1014_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_atom1097  */
static	ANTLR3_BITWORD FOLLOW_ID_in_atom1097_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_atom1097	= { FOLLOW_ID_in_atom1097_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_atom1100  */
static	ANTLR3_BITWORD FOLLOW_35_in_atom1100_bits[]	= { ANTLR3_UINT64_LIT(0x1000011840088000) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_atom1100	= { FOLLOW_35_in_atom1100_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_atom1103  */
static	ANTLR3_BITWORD FOLLOW_expr_in_atom1103_bits[]	= { ANTLR3_UINT64_LIT(0x0000009000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_atom1103	= { FOLLOW_expr_in_atom1103_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_atom1106  */
static	ANTLR3_BITWORD FOLLOW_39_in_atom1106_bits[]	= { ANTLR3_UINT64_LIT(0x1000010840088000) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_atom1106	= { FOLLOW_39_in_atom1106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_atom1108  */
static	ANTLR3_BITWORD FOLLOW_expr_in_atom1108_bits[]	= { ANTLR3_UINT64_LIT(0x0000009000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_atom1108	= { FOLLOW_expr_in_atom1108_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_atom1114  */
static	ANTLR3_BITWORD FOLLOW_36_in_atom1114_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_atom1114	= { FOLLOW_36_in_atom1114_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_atom1179  */
static	ANTLR3_BITWORD FOLLOW_35_in_atom1179_bits[]	= { ANTLR3_UINT64_LIT(0x3A88010840088000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_atom1179	= { FOLLOW_35_in_atom1179_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instruction_in_atom1181  */
static	ANTLR3_BITWORD FOLLOW_instruction_in_atom1181_bits[]	= { ANTLR3_UINT64_LIT(0x0000101000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_instruction_in_atom1181	= { FOLLOW_instruction_in_atom1181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_atom1184  */
static	ANTLR3_BITWORD FOLLOW_44_in_atom1184_bits[]	= { ANTLR3_UINT64_LIT(0x3A88010840088000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_atom1184	= { FOLLOW_44_in_atom1184_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instruction_in_atom1186  */
static	ANTLR3_BITWORD FOLLOW_instruction_in_atom1186_bits[]	= { ANTLR3_UINT64_LIT(0x0000101000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_instruction_in_atom1186	= { FOLLOW_instruction_in_atom1186_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_36_in_atom1190  */
static	ANTLR3_BITWORD FOLLOW_36_in_atom1190_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_36_in_atom1190	= { FOLLOW_36_in_atom1190_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_atom1239  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_atom1239_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_atom1239	= { FOLLOW_STRING_in_atom1239_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_in_atom1322  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_in_atom1322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_in_atom1322	= { FOLLOW_INTEGER_in_atom1322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_atom1404  */
static	ANTLR3_BITWORD FOLLOW_40_in_atom1404_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_atom1404	= { FOLLOW_40_in_atom1404_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_in_atom1406  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_in_atom1406_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_in_atom1406	= { FOLLOW_INTEGER_in_atom1406_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_atom1484  */
static	ANTLR3_BITWORD FOLLOW_60_in_atom1484_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_60_in_atom1484	= { FOLLOW_60_in_atom1484_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignExpr_in_expr1573  */
static	ANTLR3_BITWORD FOLLOW_assignExpr_in_expr1573_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignExpr_in_expr1573	= { FOLLOW_assignExpr_in_expr1573_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logExpr_in_assignExpr1583  */
static	ANTLR3_BITWORD FOLLOW_logExpr_in_assignExpr1583_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logExpr_in_assignExpr1583	= { FOLLOW_logExpr_in_assignExpr1583_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assign_in_assignExpr1592  */
static	ANTLR3_BITWORD FOLLOW_assign_in_assignExpr1592_bits[]	= { ANTLR3_UINT64_LIT(0x1000010840088000) };
static  ANTLR3_BITSET_LIST FOLLOW_assign_in_assignExpr1592	= { FOLLOW_assign_in_assignExpr1592_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logExpr_in_assignExpr1599  */
static	ANTLR3_BITWORD FOLLOW_logExpr_in_assignExpr1599_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logExpr_in_assignExpr1599	= { FOLLOW_logExpr_in_assignExpr1599_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_andExpr_in_logExpr1613  */
static	ANTLR3_BITWORD FOLLOW_andExpr_in_logExpr1613_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_andExpr_in_logExpr1613	= { FOLLOW_andExpr_in_logExpr1613_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_or_in_logExpr1626  */
static	ANTLR3_BITWORD FOLLOW_or_in_logExpr1626_bits[]	= { ANTLR3_UINT64_LIT(0x1000010840088000) };
static  ANTLR3_BITSET_LIST FOLLOW_or_in_logExpr1626	= { FOLLOW_or_in_logExpr1626_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_andExpr_in_logExpr1633  */
static	ANTLR3_BITWORD FOLLOW_andExpr_in_logExpr1633_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_andExpr_in_logExpr1633	= { FOLLOW_andExpr_in_logExpr1633_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compExpr_in_andExpr1647  */
static	ANTLR3_BITWORD FOLLOW_compExpr_in_andExpr1647_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000002) };
static  ANTLR3_BITSET_LIST FOLLOW_compExpr_in_andExpr1647	= { FOLLOW_compExpr_in_andExpr1647_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_and_in_andExpr1658  */
static	ANTLR3_BITWORD FOLLOW_and_in_andExpr1658_bits[]	= { ANTLR3_UINT64_LIT(0x1000010840088000) };
static  ANTLR3_BITSET_LIST FOLLOW_and_in_andExpr1658	= { FOLLOW_and_in_andExpr1658_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compExpr_in_andExpr1664  */
static	ANTLR3_BITWORD FOLLOW_compExpr_in_andExpr1664_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000002) };
static  ANTLR3_BITSET_LIST FOLLOW_compExpr_in_andExpr1664	= { FOLLOW_compExpr_in_andExpr1664_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addMinExpr_in_compExpr1677  */
static	ANTLR3_BITWORD FOLLOW_addMinExpr_in_compExpr1677_bits[]	= { ANTLR3_UINT64_LIT(0x0007E00000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addMinExpr_in_compExpr1677	= { FOLLOW_addMinExpr_in_compExpr1677_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comp_in_compExpr1685  */
static	ANTLR3_BITWORD FOLLOW_comp_in_compExpr1685_bits[]	= { ANTLR3_UINT64_LIT(0x1000010840088000) };
static  ANTLR3_BITSET_LIST FOLLOW_comp_in_compExpr1685	= { FOLLOW_comp_in_compExpr1685_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addMinExpr_in_compExpr1689  */
static	ANTLR3_BITWORD FOLLOW_addMinExpr_in_compExpr1689_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addMinExpr_in_compExpr1689	= { FOLLOW_addMinExpr_in_compExpr1689_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multDivExpr_in_addMinExpr1700  */
static	ANTLR3_BITWORD FOLLOW_multDivExpr_in_addMinExpr1700_bits[]	= { ANTLR3_UINT64_LIT(0x0000014000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multDivExpr_in_addMinExpr1700	= { FOLLOW_multDivExpr_in_addMinExpr1700_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addMin_in_addMinExpr1705  */
static	ANTLR3_BITWORD FOLLOW_addMin_in_addMinExpr1705_bits[]	= { ANTLR3_UINT64_LIT(0x1000010840088000) };
static  ANTLR3_BITSET_LIST FOLLOW_addMin_in_addMinExpr1705	= { FOLLOW_addMin_in_addMinExpr1705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multDivExpr_in_addMinExpr1708  */
static	ANTLR3_BITWORD FOLLOW_multDivExpr_in_addMinExpr1708_bits[]	= { ANTLR3_UINT64_LIT(0x0000014000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multDivExpr_in_addMinExpr1708	= { FOLLOW_multDivExpr_in_addMinExpr1708_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atom_in_multDivExpr1718  */
static	ANTLR3_BITWORD FOLLOW_atom_in_multDivExpr1718_bits[]	= { ANTLR3_UINT64_LIT(0x0000022000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atom_in_multDivExpr1718	= { FOLLOW_atom_in_multDivExpr1718_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multDiv_in_multDivExpr1729  */
static	ANTLR3_BITWORD FOLLOW_multDiv_in_multDivExpr1729_bits[]	= { ANTLR3_UINT64_LIT(0x1000010840088000) };
static  ANTLR3_BITSET_LIST FOLLOW_multDiv_in_multDivExpr1729	= { FOLLOW_multDiv_in_multDivExpr1729_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atom_in_multDivExpr1739  */
static	ANTLR3_BITWORD FOLLOW_atom_in_multDivExpr1739_bits[]	= { ANTLR3_UINT64_LIT(0x0000022000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atom_in_multDivExpr1739	= { FOLLOW_atom_in_multDivExpr1739_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_and1797  */
static	ANTLR3_BITWORD FOLLOW_34_in_and1797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_and1797	= { FOLLOW_34_in_and1797_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_66_in_or1810  */
static	ANTLR3_BITWORD FOLLOW_66_in_or1810_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_66_in_or1810	= { FOLLOW_66_in_or1810_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_assign1819  */
static	ANTLR3_BITWORD FOLLOW_43_in_assign1819_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_assign1819	= { FOLLOW_43_in_assign1819_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start program
 * ./src/Tiger.g:28:1: program : instructions ;
 */
static TigerParser_program_return
program(pTigerParser ctx)
{
    TigerParser_program_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_instructions_return instructions1;
    #undef	RETURN_TYPE_instructions1
    #define	RETURN_TYPE_instructions1 TigerParser_instructions_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    instructions1.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:28:9: ( instructions )
        // ./src/Tiger.g:28:11: instructions
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_instructions_in_program252);
            instructions1=instructions(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprogramEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, instructions1.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprogramEx; /* Prevent compiler warnings */
    ruleprogramEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end program */

/**
 * $ANTLR start instructions
 * ./src/Tiger.g:30:1: instructions : instruction -> ^( INSTRUCTIONS instruction ) ;
 */
static TigerParser_instructions_return
instructions(pTigerParser ctx)
{
    TigerParser_instructions_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_instruction_return instruction2;
    #undef	RETURN_TYPE_instruction2
    #define	RETURN_TYPE_instruction2 TigerParser_instruction_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_instruction;
    /* Initialize rule variables
     */

    root_0 = NULL;

    instruction2.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;



    stream_instruction   = NULL;
    #define CREATE_stream_instruction  if (stream_instruction == NULL) {stream_instruction = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule instruction"); }

    retval.tree  = NULL;

    {
        // ./src/Tiger.g:31:3: ( instruction -> ^( INSTRUCTIONS instruction ) )
        // ./src/Tiger.g:31:5: instruction
        {
            FOLLOWPUSH(FOLLOW_instruction_in_instructions263);
            instruction2=instruction(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinstructionsEx;
            }

            CREATE_stream_instruction; stream_instruction->add(stream_instruction, instruction2.tree, NULL);

            /* AST REWRITE
             * elements          : instruction
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 31:81: -> ^( INSTRUCTIONS instruction )
            	{
            	    // ./src/Tiger.g:31:84: ^( INSTRUCTIONS instruction )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, INSTRUCTIONS, (pANTLR3_UINT8)"INSTRUCTIONS")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instruction == NULL ? NULL : stream_instruction->nextTree(stream_instruction));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinstructionsEx; /* Prevent compiler warnings */
    ruleinstructionsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_instruction != NULL) stream_instruction->free(stream_instruction);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end instructions */

/**
 * $ANTLR start declaration
 * ./src/Tiger.g:36:1: declaration : ( 'var' name= ID ( ':' type= ID )? ':=' expr -> ^( VAR_DECLARATION $name ( $type)? expr ) | 'function' name= ID params ( ':' return_type= ID )? '=' instructions -> ^( FUNC_DECLARATION $name params ( $return_type)? instructions ) );
 */
static TigerParser_declaration_return
declaration(pTigerParser ctx)
{
    TigerParser_declaration_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    name;
    pANTLR3_COMMON_TOKEN    type;
    pANTLR3_COMMON_TOKEN    return_type;
    pANTLR3_COMMON_TOKEN    string_literal3;
    pANTLR3_COMMON_TOKEN    char_literal4;
    pANTLR3_COMMON_TOKEN    string_literal5;
    pANTLR3_COMMON_TOKEN    string_literal7;
    pANTLR3_COMMON_TOKEN    char_literal9;
    pANTLR3_COMMON_TOKEN    char_literal10;
    TigerParser_expr_return expr6;
    #undef	RETURN_TYPE_expr6
    #define	RETURN_TYPE_expr6 TigerParser_expr_return

    TigerParser_params_return params8;
    #undef	RETURN_TYPE_params8
    #define	RETURN_TYPE_params8 TigerParser_params_return

    TigerParser_instructions_return instructions11;
    #undef	RETURN_TYPE_instructions11
    #define	RETURN_TYPE_instructions11 TigerParser_instructions_return

    pANTLR3_BASE_TREE name_tree;
    pANTLR3_BASE_TREE type_tree;
    pANTLR3_BASE_TREE return_type_tree;
    pANTLR3_BASE_TREE string_literal3_tree;
    pANTLR3_BASE_TREE char_literal4_tree;
    pANTLR3_BASE_TREE string_literal5_tree;
    pANTLR3_BASE_TREE string_literal7_tree;
    pANTLR3_BASE_TREE char_literal9_tree;
    pANTLR3_BASE_TREE char_literal10_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_48;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_42;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_64;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_43;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_instructions;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_expr;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_params;
    /* Initialize rule variables
     */

    root_0 = NULL;

    name       = NULL;
    type       = NULL;
    return_type       = NULL;
    string_literal3       = NULL;
    char_literal4       = NULL;
    string_literal5       = NULL;
    string_literal7       = NULL;
    char_literal9       = NULL;
    char_literal10       = NULL;
    expr6.tree = NULL;

    params8.tree = NULL;

    instructions11.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    name_tree   = NULL;
    type_tree   = NULL;
    return_type_tree   = NULL;
    string_literal3_tree   = NULL;
    char_literal4_tree   = NULL;
    string_literal5_tree   = NULL;
    string_literal7_tree   = NULL;
    char_literal9_tree   = NULL;
    char_literal10_tree   = NULL;

    stream_56   = NULL;
    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 56"); } 
    stream_48   = NULL;
    #define CREATE_stream_48  if (stream_48 == NULL) {stream_48 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 48"); } 
    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 
    stream_42   = NULL;
    #define CREATE_stream_42  if (stream_42 == NULL) {stream_42 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 42"); } 
    stream_64   = NULL;
    #define CREATE_stream_64  if (stream_64 == NULL) {stream_64 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 64"); } 
    stream_43   = NULL;
    #define CREATE_stream_43  if (stream_43 == NULL) {stream_43 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 43"); } 
    stream_instructions   = NULL;
    #define CREATE_stream_instructions  if (stream_instructions == NULL) {stream_instructions = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule instructions"); }
    stream_expr   = NULL;
    #define CREATE_stream_expr  if (stream_expr == NULL) {stream_expr = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule expr"); }
    stream_params   = NULL;
    #define CREATE_stream_params  if (stream_params == NULL) {stream_params = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule params"); }

    retval.tree  = NULL;

    {
        {
            //  ./src/Tiger.g:37:3: ( 'var' name= ID ( ':' type= ID )? ':=' expr -> ^( VAR_DECLARATION $name ( $type)? expr ) | 'function' name= ID params ( ':' return_type= ID )? '=' instructions -> ^( FUNC_DECLARATION $name params ( $return_type)? instructions ) )

            ANTLR3_UINT32 alt3;

            alt3=2;

            switch ( LA(1) )
            {
            case 64:
            	{
            		alt3=1;
            	}
                break;
            case 56:
            	{
            		alt3=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 3;
                EXCEPTION->state        = 0;


                goto ruledeclarationEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // ./src/Tiger.g:37:5: 'var' name= ID ( ':' type= ID )? ':=' expr
        	    {
        	        string_literal3 = (pANTLR3_COMMON_TOKEN) MATCHT(64, &FOLLOW_64_in_declaration350);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }
        	         
        	        CREATE_stream_64; stream_64->add(stream_64, string_literal3, NULL);


        	        name = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_declaration354);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, name, NULL);


        	        // ./src/Tiger.g:37:19: ( ':' type= ID )?
        	        {
        	            int alt1=2;
        	            switch ( LA(1) )
        	            {
        	                case 42:
        	                	{
        	                		alt1=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt1)
        	            {
        	        	case 1:
        	        	    // ./src/Tiger.g:37:20: ':' type= ID
        	        	    {
        	        	        char_literal4 = (pANTLR3_COMMON_TOKEN) MATCHT(42, &FOLLOW_42_in_declaration357);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclarationEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_42; stream_42->add(stream_42, char_literal4, NULL);


        	        	        type = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_declaration361);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclarationEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_ID; stream_ID->add(stream_ID, type, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        string_literal5 = (pANTLR3_COMMON_TOKEN) MATCHT(43, &FOLLOW_43_in_declaration365);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }
        	         
        	        CREATE_stream_43; stream_43->add(stream_43, string_literal5, NULL);


        	        FOLLOWPUSH(FOLLOW_expr_in_declaration367);
        	        expr6=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }

        	        CREATE_stream_expr; stream_expr->add(stream_expr, expr6.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : type, name, expr
        	         * token labels      : name, type
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_name;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_type;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_name=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token name", name);
        	        	stream_type=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token type", type);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 37:81: -> ^( VAR_DECLARATION $name ( $type)? expr )
        	        	{
        	        	    // ./src/Tiger.g:37:84: ^( VAR_DECLARATION $name ( $type)? expr )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, VAR_DECLARATION, (pANTLR3_UINT8)"VAR_DECLARATION")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_name == NULL ? NULL : stream_name->nextNode(stream_name));

        	        	        // ./src/Tiger.g:37:109: ( $type)?
        	        	        {
        	        	        	if ( (stream_type != NULL && stream_type->hasNext(stream_type))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_type == NULL ? NULL : stream_type->nextNode(stream_type));

        	        	        	}
        	        	        	if ( stream_type != NULL) stream_type->reset(stream_type);

        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_expr == NULL ? NULL : stream_expr->nextTree(stream_expr));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_name != NULL) stream_name->free(stream_name); 
        	        	if (stream_type != NULL) stream_type->free(stream_type); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // ./src/Tiger.g:38:5: 'function' name= ID params ( ':' return_type= ID )? '=' instructions
        	    {
        	        string_literal7 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_declaration425);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }
        	         
        	        CREATE_stream_56; stream_56->add(stream_56, string_literal7, NULL);


        	        name = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_declaration429);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, name, NULL);


        	        FOLLOWPUSH(FOLLOW_params_in_declaration431);
        	        params8=params(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }

        	        CREATE_stream_params; stream_params->add(stream_params, params8.tree, NULL);

        	        // ./src/Tiger.g:38:31: ( ':' return_type= ID )?
        	        {
        	            int alt2=2;
        	            switch ( LA(1) )
        	            {
        	                case 42:
        	                	{
        	                		alt2=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt2)
        	            {
        	        	case 1:
        	        	    // ./src/Tiger.g:38:32: ':' return_type= ID
        	        	    {
        	        	        char_literal9 = (pANTLR3_COMMON_TOKEN) MATCHT(42, &FOLLOW_42_in_declaration434);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclarationEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_42; stream_42->add(stream_42, char_literal9, NULL);


        	        	        return_type = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_declaration438);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclarationEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_ID; stream_ID->add(stream_ID, return_type, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        char_literal10 = (pANTLR3_COMMON_TOKEN) MATCHT(48, &FOLLOW_48_in_declaration442);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }
        	         
        	        CREATE_stream_48; stream_48->add(stream_48, char_literal10, NULL);


        	        FOLLOWPUSH(FOLLOW_instructions_in_declaration444);
        	        instructions11=instructions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }

        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, instructions11.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : instructions, params, name, return_type
        	         * token labels      : return_type, name
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_return_type;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_name;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_return_type=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token return_type", return_type);
        	        	stream_name=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token name", name);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 38:81: -> ^( FUNC_DECLARATION $name params ( $return_type)? instructions )
        	        	{
        	        	    // ./src/Tiger.g:38:84: ^( FUNC_DECLARATION $name params ( $return_type)? instructions )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FUNC_DECLARATION, (pANTLR3_UINT8)"FUNC_DECLARATION")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_name == NULL ? NULL : stream_name->nextNode(stream_name));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_params == NULL ? NULL : stream_params->nextTree(stream_params));

        	        	        // ./src/Tiger.g:38:117: ( $return_type)?
        	        	        {
        	        	        	if ( (stream_return_type != NULL && stream_return_type->hasNext(stream_return_type))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_return_type == NULL ? NULL : stream_return_type->nextNode(stream_return_type));

        	        	        	}
        	        	        	if ( stream_return_type != NULL) stream_return_type->reset(stream_return_type);

        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instructions == NULL ? NULL : stream_instructions->nextTree(stream_instructions));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_return_type != NULL) stream_return_type->free(stream_return_type); 
        	        	if (stream_name != NULL) stream_name->free(stream_name); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledeclarationEx; /* Prevent compiler warnings */
    ruledeclarationEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_56 != NULL) stream_56->free(stream_56);
        if (stream_48 != NULL) stream_48->free(stream_48);
        if (stream_ID != NULL) stream_ID->free(stream_ID);
        if (stream_42 != NULL) stream_42->free(stream_42);
        if (stream_64 != NULL) stream_64->free(stream_64);
        if (stream_43 != NULL) stream_43->free(stream_43);
        if (stream_instructions != NULL) stream_instructions->free(stream_instructions);
        if (stream_expr != NULL) stream_expr->free(stream_expr);
        if (stream_params != NULL) stream_params->free(stream_params);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end declaration */

/**
 * $ANTLR start params
 * ./src/Tiger.g:41:1: params : '(' ( param ( ',' param )* )? ')' -> ^( PARAMS ( param )* ) ;
 */
static TigerParser_params_return
params(pTigerParser ctx)
{
    TigerParser_params_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal12;
    pANTLR3_COMMON_TOKEN    char_literal14;
    pANTLR3_COMMON_TOKEN    char_literal16;
    TigerParser_param_return param13;
    #undef	RETURN_TYPE_param13
    #define	RETURN_TYPE_param13 TigerParser_param_return

    TigerParser_param_return param15;
    #undef	RETURN_TYPE_param15
    #define	RETURN_TYPE_param15 TigerParser_param_return

    pANTLR3_BASE_TREE char_literal12_tree;
    pANTLR3_BASE_TREE char_literal14_tree;
    pANTLR3_BASE_TREE char_literal16_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_35;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_36;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_39;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_param;
    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal12       = NULL;
    char_literal14       = NULL;
    char_literal16       = NULL;
    param13.tree = NULL;

    param15.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal12_tree   = NULL;
    char_literal14_tree   = NULL;
    char_literal16_tree   = NULL;

    stream_35   = NULL;
    #define CREATE_stream_35  if (stream_35 == NULL) {stream_35 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 35"); } 
    stream_36   = NULL;
    #define CREATE_stream_36  if (stream_36 == NULL) {stream_36 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 36"); } 
    stream_39   = NULL;
    #define CREATE_stream_39  if (stream_39 == NULL) {stream_39 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 39"); } 
    stream_param   = NULL;
    #define CREATE_stream_param  if (stream_param == NULL) {stream_param = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule param"); }

    retval.tree  = NULL;

    {
        // ./src/Tiger.g:42:3: ( '(' ( param ( ',' param )* )? ')' -> ^( PARAMS ( param )* ) )
        // ./src/Tiger.g:42:5: '(' ( param ( ',' param )* )? ')'
        {
            char_literal12 = (pANTLR3_COMMON_TOKEN) MATCHT(35, &FOLLOW_35_in_params485);
            if  (HASEXCEPTION())
            {
                goto ruleparamsEx;
            }
             
            CREATE_stream_35; stream_35->add(stream_35, char_literal12, NULL);


            // ./src/Tiger.g:42:9: ( param ( ',' param )* )?
            {
                int alt5=2;
                switch ( LA(1) )
                {
                    case ID:
                    	{
                    		alt5=1;
                    	}
                        break;
                }

                switch (alt5)
                {
            	case 1:
            	    // ./src/Tiger.g:42:11: param ( ',' param )*
            	    {
            	        FOLLOWPUSH(FOLLOW_param_in_params489);
            	        param13=param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparamsEx;
            	        }

            	        CREATE_stream_param; stream_param->add(stream_param, param13.tree, NULL);

            	        // ./src/Tiger.g:42:17: ( ',' param )*

            	        for (;;)
            	        {
            	            int alt4=2;
            	            switch ( LA(1) )
            	            {
            	            case 39:
            	            	{
            	            		alt4=1;
            	            	}
            	                break;

            	            }

            	            switch (alt4)
            	            {
            	        	case 1:
            	        	    // ./src/Tiger.g:42:18: ',' param
            	        	    {
            	        	        char_literal14 = (pANTLR3_COMMON_TOKEN) MATCHT(39, &FOLLOW_39_in_params492);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleparamsEx;
            	        	        }
            	        	         
            	        	        CREATE_stream_39; stream_39->add(stream_39, char_literal14, NULL);


            	        	        FOLLOWPUSH(FOLLOW_param_in_params494);
            	        	        param15=param(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleparamsEx;
            	        	        }

            	        	        CREATE_stream_param; stream_param->add(stream_param, param15.tree, NULL);

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop4;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop4: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            char_literal16 = (pANTLR3_COMMON_TOKEN) MATCHT(36, &FOLLOW_36_in_params500);
            if  (HASEXCEPTION())
            {
                goto ruleparamsEx;
            }
             
            CREATE_stream_36; stream_36->add(stream_36, char_literal16, NULL);


            /* AST REWRITE
             * elements          : param
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 42:81: -> ^( PARAMS ( param )* )
            	{
            	    // ./src/Tiger.g:42:84: ^( PARAMS ( param )* )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PARAMS, (pANTLR3_UINT8)"PARAMS")
            	        , root_1));

            	        // ./src/Tiger.g:42:93: ( param )*
            	        {
            	        	while ( (stream_param != NULL && stream_param->hasNext(stream_param))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_param == NULL ? NULL : stream_param->nextTree(stream_param));

            	        	}
            	        	if (stream_param != NULL) stream_param->reset(stream_param);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparamsEx; /* Prevent compiler warnings */
    ruleparamsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_35 != NULL) stream_35->free(stream_35);
        if (stream_36 != NULL) stream_36->free(stream_36);
        if (stream_39 != NULL) stream_39->free(stream_39);
        if (stream_param != NULL) stream_param->free(stream_param);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end params */

/**
 * $ANTLR start param
 * ./src/Tiger.g:44:1: param : name= ID ':' type= ID -> ^( PARAM $name $type) ;
 */
static TigerParser_param_return
param(pTigerParser ctx)
{
    TigerParser_param_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    name;
    pANTLR3_COMMON_TOKEN    type;
    pANTLR3_COMMON_TOKEN    char_literal17;

    pANTLR3_BASE_TREE name_tree;
    pANTLR3_BASE_TREE type_tree;
    pANTLR3_BASE_TREE char_literal17_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_42;

    /* Initialize rule variables
     */

    root_0 = NULL;

    name       = NULL;
    type       = NULL;
    char_literal17       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    name_tree   = NULL;
    type_tree   = NULL;
    char_literal17_tree   = NULL;

    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 
    stream_42   = NULL;
    #define CREATE_stream_42  if (stream_42 == NULL) {stream_42 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 42"); } 

    retval.tree  = NULL;

    {
        // ./src/Tiger.g:45:3: (name= ID ':' type= ID -> ^( PARAM $name $type) )
        // ./src/Tiger.g:45:5: name= ID ':' type= ID
        {
            name = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_param568);
            if  (HASEXCEPTION())
            {
                goto ruleparamEx;
            }
             
            CREATE_stream_ID; stream_ID->add(stream_ID, name, NULL);


            char_literal17 = (pANTLR3_COMMON_TOKEN) MATCHT(42, &FOLLOW_42_in_param570);
            if  (HASEXCEPTION())
            {
                goto ruleparamEx;
            }
             
            CREATE_stream_42; stream_42->add(stream_42, char_literal17, NULL);


            type = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_param574);
            if  (HASEXCEPTION())
            {
                goto ruleparamEx;
            }
             
            CREATE_stream_ID; stream_ID->add(stream_ID, type, NULL);


            /* AST REWRITE
             * elements          : type, name
             * token labels      : name, type
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_name;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_type;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_name=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token name", name);
            	stream_type=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token type", type);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 45:81: -> ^( PARAM $name $type)
            	{
            	    // ./src/Tiger.g:45:84: ^( PARAM $name $type)
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PARAM, (pANTLR3_UINT8)"PARAM")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_name == NULL ? NULL : stream_name->nextNode(stream_name));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_type == NULL ? NULL : stream_type->nextNode(stream_type));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_name != NULL) stream_name->free(stream_name); 
            	if (stream_type != NULL) stream_type->free(stream_type); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparamEx; /* Prevent compiler warnings */
    ruleparamEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_ID != NULL) stream_ID->free(stream_ID);
        if (stream_42 != NULL) stream_42->free(stream_42);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end param */

/**
 * $ANTLR start instruction
 * ./src/Tiger.g:50:1: instruction : ( 'let' ( declaration )+ 'in' instructions 'end' -> ^( LET ^( DECLARATIONS ( declaration )+ ) instructions ) | expr | 'if' expr 'then' i1= instructions ( options {greedy=true; } : 'else' i2= instructions )? -> ^( IF expr $i1 ( $i2)? ) | 'while' expr 'do' instructions -> ^( WHILE expr instructions ) | 'for' ID ':=' v1= expr 'to' v2= expr 'do' instructions -> ^( FOR ID $v1 $v2 instructions ) | 'break' -> BREAK | 'return' expr -> ^( RETURN expr ) );
 */
static TigerParser_instruction_return
instruction(pTigerParser ctx)
{
    TigerParser_instruction_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal18;
    pANTLR3_COMMON_TOKEN    string_literal20;
    pANTLR3_COMMON_TOKEN    string_literal22;
    pANTLR3_COMMON_TOKEN    string_literal24;
    pANTLR3_COMMON_TOKEN    string_literal26;
    pANTLR3_COMMON_TOKEN    string_literal27;
    pANTLR3_COMMON_TOKEN    string_literal28;
    pANTLR3_COMMON_TOKEN    string_literal30;
    pANTLR3_COMMON_TOKEN    string_literal32;
    pANTLR3_COMMON_TOKEN    ID33;
    pANTLR3_COMMON_TOKEN    string_literal34;
    pANTLR3_COMMON_TOKEN    string_literal35;
    pANTLR3_COMMON_TOKEN    string_literal36;
    pANTLR3_COMMON_TOKEN    string_literal38;
    pANTLR3_COMMON_TOKEN    string_literal39;
    TigerParser_instructions_return i1;
    #undef	RETURN_TYPE_i1
    #define	RETURN_TYPE_i1 TigerParser_instructions_return

    TigerParser_instructions_return i2;
    #undef	RETURN_TYPE_i2
    #define	RETURN_TYPE_i2 TigerParser_instructions_return

    TigerParser_expr_return v1;
    #undef	RETURN_TYPE_v1
    #define	RETURN_TYPE_v1 TigerParser_expr_return

    TigerParser_expr_return v2;
    #undef	RETURN_TYPE_v2
    #define	RETURN_TYPE_v2 TigerParser_expr_return

    TigerParser_declaration_return declaration19;
    #undef	RETURN_TYPE_declaration19
    #define	RETURN_TYPE_declaration19 TigerParser_declaration_return

    TigerParser_instructions_return instructions21;
    #undef	RETURN_TYPE_instructions21
    #define	RETURN_TYPE_instructions21 TigerParser_instructions_return

    TigerParser_expr_return expr23;
    #undef	RETURN_TYPE_expr23
    #define	RETURN_TYPE_expr23 TigerParser_expr_return

    TigerParser_expr_return expr25;
    #undef	RETURN_TYPE_expr25
    #define	RETURN_TYPE_expr25 TigerParser_expr_return

    TigerParser_expr_return expr29;
    #undef	RETURN_TYPE_expr29
    #define	RETURN_TYPE_expr29 TigerParser_expr_return

    TigerParser_instructions_return instructions31;
    #undef	RETURN_TYPE_instructions31
    #define	RETURN_TYPE_instructions31 TigerParser_instructions_return

    TigerParser_instructions_return instructions37;
    #undef	RETURN_TYPE_instructions37
    #define	RETURN_TYPE_instructions37 TigerParser_instructions_return

    TigerParser_expr_return expr40;
    #undef	RETURN_TYPE_expr40
    #define	RETURN_TYPE_expr40 TigerParser_expr_return

    pANTLR3_BASE_TREE string_literal18_tree;
    pANTLR3_BASE_TREE string_literal20_tree;
    pANTLR3_BASE_TREE string_literal22_tree;
    pANTLR3_BASE_TREE string_literal24_tree;
    pANTLR3_BASE_TREE string_literal26_tree;
    pANTLR3_BASE_TREE string_literal27_tree;
    pANTLR3_BASE_TREE string_literal28_tree;
    pANTLR3_BASE_TREE string_literal30_tree;
    pANTLR3_BASE_TREE string_literal32_tree;
    pANTLR3_BASE_TREE ID33_tree;
    pANTLR3_BASE_TREE string_literal34_tree;
    pANTLR3_BASE_TREE string_literal35_tree;
    pANTLR3_BASE_TREE string_literal36_tree;
    pANTLR3_BASE_TREE string_literal38_tree;
    pANTLR3_BASE_TREE string_literal39_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_55;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_57;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_58;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_59;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_61;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_62;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_51;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_52;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_63;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_53;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_65;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_43;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_instructions;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_expr;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_declaration;
    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal18       = NULL;
    string_literal20       = NULL;
    string_literal22       = NULL;
    string_literal24       = NULL;
    string_literal26       = NULL;
    string_literal27       = NULL;
    string_literal28       = NULL;
    string_literal30       = NULL;
    string_literal32       = NULL;
    ID33       = NULL;
    string_literal34       = NULL;
    string_literal35       = NULL;
    string_literal36       = NULL;
    string_literal38       = NULL;
    string_literal39       = NULL;
    i1.tree = NULL;

    i2.tree = NULL;

    v1.tree = NULL;

    v2.tree = NULL;

    declaration19.tree = NULL;

    instructions21.tree = NULL;

    expr23.tree = NULL;

    expr25.tree = NULL;

    expr29.tree = NULL;

    instructions31.tree = NULL;

    instructions37.tree = NULL;

    expr40.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal18_tree   = NULL;
    string_literal20_tree   = NULL;
    string_literal22_tree   = NULL;
    string_literal24_tree   = NULL;
    string_literal26_tree   = NULL;
    string_literal27_tree   = NULL;
    string_literal28_tree   = NULL;
    string_literal30_tree   = NULL;
    string_literal32_tree   = NULL;
    ID33_tree   = NULL;
    string_literal34_tree   = NULL;
    string_literal35_tree   = NULL;
    string_literal36_tree   = NULL;
    string_literal38_tree   = NULL;
    string_literal39_tree   = NULL;

    stream_55   = NULL;
    #define CREATE_stream_55  if (stream_55 == NULL) {stream_55 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 55"); } 
    stream_57   = NULL;
    #define CREATE_stream_57  if (stream_57 == NULL) {stream_57 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 57"); } 
    stream_58   = NULL;
    #define CREATE_stream_58  if (stream_58 == NULL) {stream_58 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 58"); } 
    stream_59   = NULL;
    #define CREATE_stream_59  if (stream_59 == NULL) {stream_59 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 59"); } 
    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 
    stream_61   = NULL;
    #define CREATE_stream_61  if (stream_61 == NULL) {stream_61 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 61"); } 
    stream_62   = NULL;
    #define CREATE_stream_62  if (stream_62 == NULL) {stream_62 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 62"); } 
    stream_51   = NULL;
    #define CREATE_stream_51  if (stream_51 == NULL) {stream_51 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 51"); } 
    stream_52   = NULL;
    #define CREATE_stream_52  if (stream_52 == NULL) {stream_52 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 52"); } 
    stream_63   = NULL;
    #define CREATE_stream_63  if (stream_63 == NULL) {stream_63 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 63"); } 
    stream_53   = NULL;
    #define CREATE_stream_53  if (stream_53 == NULL) {stream_53 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 53"); } 
    stream_54   = NULL;
    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 54"); } 
    stream_65   = NULL;
    #define CREATE_stream_65  if (stream_65 == NULL) {stream_65 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 65"); } 
    stream_43   = NULL;
    #define CREATE_stream_43  if (stream_43 == NULL) {stream_43 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 43"); } 
    stream_instructions   = NULL;
    #define CREATE_stream_instructions  if (stream_instructions == NULL) {stream_instructions = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule instructions"); }
    stream_expr   = NULL;
    #define CREATE_stream_expr  if (stream_expr == NULL) {stream_expr = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule expr"); }
    stream_declaration   = NULL;
    #define CREATE_stream_declaration  if (stream_declaration == NULL) {stream_declaration = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule declaration"); }

    retval.tree  = NULL;

    {
        {
            //  ./src/Tiger.g:51:3: ( 'let' ( declaration )+ 'in' instructions 'end' -> ^( LET ^( DECLARATIONS ( declaration )+ ) instructions ) | expr | 'if' expr 'then' i1= instructions ( options {greedy=true; } : 'else' i2= instructions )? -> ^( IF expr $i1 ( $i2)? ) | 'while' expr 'do' instructions -> ^( WHILE expr instructions ) | 'for' ID ':=' v1= expr 'to' v2= expr 'do' instructions -> ^( FOR ID $v1 $v2 instructions ) | 'break' -> BREAK | 'return' expr -> ^( RETURN expr ) )

            ANTLR3_UINT32 alt8;

            alt8=7;

            switch ( LA(1) )
            {
            case 59:
            	{
            		alt8=1;
            	}
                break;
            case ID:
            case INTEGER:
            case STRING:
            case 35:
            case 40:
            case 60:
            	{
            		alt8=2;
            	}
                break;
            case 57:
            	{
            		alt8=3;
            	}
                break;
            case 65:
            	{
            		alt8=4;
            	}
                break;
            case 55:
            	{
            		alt8=5;
            	}
                break;
            case 51:
            	{
            		alt8=6;
            	}
                break;
            case 61:
            	{
            		alt8=7;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 8;
                EXCEPTION->state        = 0;


                goto ruleinstructionEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // ./src/Tiger.g:51:5: 'let' ( declaration )+ 'in' instructions 'end'
        	    {
        	        string_literal18 = (pANTLR3_COMMON_TOKEN) MATCHT(59, &FOLLOW_59_in_instruction657);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_59; stream_59->add(stream_59, string_literal18, NULL);


        	        // ./src/Tiger.g:51:11: ( declaration )+
        	        {
        	            int cnt6=0;

        	            for (;;)
        	            {
        	                int alt6=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case 56:
        	        	case 64:
        	        		{
        	        			alt6=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt6)
        	        	{
        	        	    case 1:
        	        	        // ./src/Tiger.g:51:11: declaration
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_declaration_in_instruction659);
        	        	            declaration19=declaration(ctx);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleinstructionEx;
        	        	            }

        	        	            CREATE_stream_declaration; stream_declaration->add(stream_declaration, declaration19.tree, NULL);

        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt6 >= 1 )
        	        		{
        	        		    goto loop6;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleinstructionEx;
        	        	}
        	        	cnt6++;
        	            }
        	            loop6: ;	/* Jump to here if this rule does not match */
        	        }

        	        string_literal20 = (pANTLR3_COMMON_TOKEN) MATCHT(58, &FOLLOW_58_in_instruction662);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_58; stream_58->add(stream_58, string_literal20, NULL);


        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction664);
        	        instructions21=instructions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, instructions21.tree, NULL);

        	        string_literal22 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_instruction666);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_54; stream_54->add(stream_54, string_literal22, NULL);


        	        /* AST REWRITE
        	         * elements          : declaration, instructions
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 51:81: -> ^( LET ^( DECLARATIONS ( declaration )+ ) instructions )
        	        	{
        	        	    // ./src/Tiger.g:51:84: ^( LET ^( DECLARATIONS ( declaration )+ ) instructions )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, LET, (pANTLR3_UINT8)"LET")
        	        	        , root_1));

        	        	        // ./src/Tiger.g:51:90: ^( DECLARATIONS ( declaration )+ )
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	            (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, DECLARATIONS, (pANTLR3_UINT8)"DECLARATIONS")
        	        	            , root_2));

        	        	            if ((stream_declaration == NULL || !stream_declaration->hasNext(stream_declaration))  )
        	        	            {
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;
        	        	                EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;
        	        	            }
        	        	            else
        	        	            {
        	        	            	while ( (stream_declaration->hasNext(stream_declaration))  ) {
        	        	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_declaration == NULL ? NULL : stream_declaration->nextTree(stream_declaration));

        	        	            	}
        	        	            	stream_declaration->reset(stream_declaration);

        	        	            }
        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instructions == NULL ? NULL : stream_instructions->nextTree(stream_instructions));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // ./src/Tiger.g:53:5: expr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_expr_in_instruction721);
        	        expr23=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, expr23.tree);

        	    }
        	    break;
        	case 3:
        	    // ./src/Tiger.g:55:5: 'if' expr 'then' i1= instructions ( options {greedy=true; } : 'else' i2= instructions )?
        	    {
        	        string_literal24 = (pANTLR3_COMMON_TOKEN) MATCHT(57, &FOLLOW_57_in_instruction728);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_57; stream_57->add(stream_57, string_literal24, NULL);


        	        FOLLOWPUSH(FOLLOW_expr_in_instruction730);
        	        expr25=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_expr; stream_expr->add(stream_expr, expr25.tree, NULL);

        	        string_literal26 = (pANTLR3_COMMON_TOKEN) MATCHT(62, &FOLLOW_62_in_instruction732);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_62; stream_62->add(stream_62, string_literal26, NULL);


        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction736);
        	        i1=instructions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, i1.tree, NULL);

        	        // ./src/Tiger.g:56:5: ( options {greedy=true; } : 'else' i2= instructions )?
        	        {
        	            int alt7=2;
        	            switch ( LA(1) )
        	            {
        	                case 53:
        	                	{
        	                		alt7=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt7)
        	            {
        	        	case 1:
        	        	    // ./src/Tiger.g:56:31: 'else' i2= instructions
        	        	    {
        	        	        string_literal27 = (pANTLR3_COMMON_TOKEN) MATCHT(53, &FOLLOW_53_in_instruction752);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleinstructionEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_53; stream_53->add(stream_53, string_literal27, NULL);


        	        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction756);
        	        	        i2=instructions(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleinstructionEx;
        	        	        }

        	        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, i2.tree, NULL);

        	        	    }
        	        	    break;

        	            }
        	        }

        	        /* AST REWRITE
        	         * elements          : i1, expr, i2
        	         * token labels      : 
        	         * rule labels       : i1, i2, retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_i1;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_i2;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_i1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token i1", i1.tree != NULL ? i1.tree : NULL);
        	        	stream_i2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token i2", i2.tree != NULL ? i2.tree : NULL);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 56:81: -> ^( IF expr $i1 ( $i2)? )
        	        	{
        	        	    // ./src/Tiger.g:56:84: ^( IF expr $i1 ( $i2)? )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IF, (pANTLR3_UINT8)"IF")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_expr == NULL ? NULL : stream_expr->nextTree(stream_expr));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_i1 == NULL ? NULL : stream_i1->nextTree(stream_i1));

        	        	        // ./src/Tiger.g:56:99: ( $i2)?
        	        	        {
        	        	        	if ( (stream_i2 != NULL && stream_i2->hasNext(stream_i2))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_i2 == NULL ? NULL : stream_i2->nextTree(stream_i2));

        	        	        	}
        	        	        	if ( stream_i2 != NULL) stream_i2->reset(stream_i2);

        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_i1 != NULL) stream_i1->free(stream_i1);
        	        	if (stream_i2 != NULL) stream_i2->free(stream_i2);
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 4:
        	    // ./src/Tiger.g:57:5: 'while' expr 'do' instructions
        	    {
        	        string_literal28 = (pANTLR3_COMMON_TOKEN) MATCHT(65, &FOLLOW_65_in_instruction804);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_65; stream_65->add(stream_65, string_literal28, NULL);


        	        FOLLOWPUSH(FOLLOW_expr_in_instruction806);
        	        expr29=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_expr; stream_expr->add(stream_expr, expr29.tree, NULL);

        	        string_literal30 = (pANTLR3_COMMON_TOKEN) MATCHT(52, &FOLLOW_52_in_instruction808);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_52; stream_52->add(stream_52, string_literal30, NULL);


        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction810);
        	        instructions31=instructions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, instructions31.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : expr, instructions
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 57:81: -> ^( WHILE expr instructions )
        	        	{
        	        	    // ./src/Tiger.g:57:84: ^( WHILE expr instructions )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WHILE, (pANTLR3_UINT8)"WHILE")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_expr == NULL ? NULL : stream_expr->nextTree(stream_expr));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instructions == NULL ? NULL : stream_instructions->nextTree(stream_instructions));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 5:
        	    // ./src/Tiger.g:58:5: 'for' ID ':=' v1= expr 'to' v2= expr 'do' instructions
        	    {
        	        string_literal32 = (pANTLR3_COMMON_TOKEN) MATCHT(55, &FOLLOW_55_in_instruction871);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_55; stream_55->add(stream_55, string_literal32, NULL);


        	        ID33 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_instruction873);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, ID33, NULL);


        	        string_literal34 = (pANTLR3_COMMON_TOKEN) MATCHT(43, &FOLLOW_43_in_instruction875);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_43; stream_43->add(stream_43, string_literal34, NULL);


        	        FOLLOWPUSH(FOLLOW_expr_in_instruction879);
        	        v1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_expr; stream_expr->add(stream_expr, v1.tree, NULL);

        	        string_literal35 = (pANTLR3_COMMON_TOKEN) MATCHT(63, &FOLLOW_63_in_instruction881);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_63; stream_63->add(stream_63, string_literal35, NULL);


        	        FOLLOWPUSH(FOLLOW_expr_in_instruction885);
        	        v2=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_expr; stream_expr->add(stream_expr, v2.tree, NULL);

        	        string_literal36 = (pANTLR3_COMMON_TOKEN) MATCHT(52, &FOLLOW_52_in_instruction887);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_52; stream_52->add(stream_52, string_literal36, NULL);


        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction889);
        	        instructions37=instructions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, instructions37.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : v1, instructions, ID, v2
        	         * token labels      : 
        	         * rule labels       : v1, v2, retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_v1;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_v2;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_v1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token v1", v1.tree != NULL ? v1.tree : NULL);
        	        	stream_v2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token v2", v2.tree != NULL ? v2.tree : NULL);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 58:81: -> ^( FOR ID $v1 $v2 instructions )
        	        	{
        	        	    // ./src/Tiger.g:58:84: ^( FOR ID $v1 $v2 instructions )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FOR, (pANTLR3_UINT8)"FOR")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_ID == NULL ? NULL : stream_ID->nextNode(stream_ID)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_v1 == NULL ? NULL : stream_v1->nextTree(stream_v1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_v2 == NULL ? NULL : stream_v2->nextTree(stream_v2));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instructions == NULL ? NULL : stream_instructions->nextTree(stream_instructions));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_v1 != NULL) stream_v1->free(stream_v1);
        	        	if (stream_v2 != NULL) stream_v2->free(stream_v2);
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 6:
        	    // ./src/Tiger.g:59:5: 'break'
        	    {
        	        string_literal38 = (pANTLR3_COMMON_TOKEN) MATCHT(51, &FOLLOW_51_in_instruction934);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_51; stream_51->add(stream_51, string_literal38, NULL);


        	        /* AST REWRITE
        	         * elements          : 
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 59:81: -> BREAK
        	        	{
        	        	    ADAPTOR->addChild(ADAPTOR, root_0, 
        	        	    (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BREAK, (pANTLR3_UINT8)"BREAK")
        	        	    );

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 7:
        	    // ./src/Tiger.g:60:5: 'return' expr
        	    {
        	        string_literal39 = (pANTLR3_COMMON_TOKEN) MATCHT(61, &FOLLOW_61_in_instruction1012);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_61; stream_61->add(stream_61, string_literal39, NULL);


        	        FOLLOWPUSH(FOLLOW_expr_in_instruction1014);
        	        expr40=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_expr; stream_expr->add(stream_expr, expr40.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : expr
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 60:81: -> ^( RETURN expr )
        	        	{
        	        	    // ./src/Tiger.g:60:84: ^( RETURN expr )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, RETURN, (pANTLR3_UINT8)"RETURN")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_expr == NULL ? NULL : stream_expr->nextTree(stream_expr));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleinstructionEx; /* Prevent compiler warnings */
    ruleinstructionEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_55 != NULL) stream_55->free(stream_55);
        if (stream_57 != NULL) stream_57->free(stream_57);
        if (stream_58 != NULL) stream_58->free(stream_58);
        if (stream_59 != NULL) stream_59->free(stream_59);
        if (stream_ID != NULL) stream_ID->free(stream_ID);
        if (stream_61 != NULL) stream_61->free(stream_61);
        if (stream_62 != NULL) stream_62->free(stream_62);
        if (stream_51 != NULL) stream_51->free(stream_51);
        if (stream_52 != NULL) stream_52->free(stream_52);
        if (stream_63 != NULL) stream_63->free(stream_63);
        if (stream_53 != NULL) stream_53->free(stream_53);
        if (stream_54 != NULL) stream_54->free(stream_54);
        if (stream_65 != NULL) stream_65->free(stream_65);
        if (stream_43 != NULL) stream_43->free(stream_43);
        if (stream_instructions != NULL) stream_instructions->free(stream_instructions);
        if (stream_expr != NULL) stream_expr->free(stream_expr);
        if (stream_declaration != NULL) stream_declaration->free(stream_declaration);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end instruction */

/**
 * $ANTLR start atom
 * ./src/Tiger.g:63:1: atom : ( ID ( '(' ( expr ( ',' expr )* )? ')' )? -> ^( ID ( ^( ARGS ( expr )* ) )? ) | '(' instruction ( ';' instruction )* ')' -> ( instruction )+ | STRING -> ^( STR STRING ) | INTEGER -> ^( INT INTEGER ) | '-' INTEGER -> ^( NEG INTEGER ) | 'nil' -> ^( NIL ) );
 */
static TigerParser_atom_return
atom(pTigerParser ctx)
{
    TigerParser_atom_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ID41;
    pANTLR3_COMMON_TOKEN    char_literal42;
    pANTLR3_COMMON_TOKEN    char_literal44;
    pANTLR3_COMMON_TOKEN    char_literal46;
    pANTLR3_COMMON_TOKEN    char_literal47;
    pANTLR3_COMMON_TOKEN    char_literal49;
    pANTLR3_COMMON_TOKEN    char_literal51;
    pANTLR3_COMMON_TOKEN    STRING52;
    pANTLR3_COMMON_TOKEN    INTEGER53;
    pANTLR3_COMMON_TOKEN    char_literal54;
    pANTLR3_COMMON_TOKEN    INTEGER55;
    pANTLR3_COMMON_TOKEN    string_literal56;
    TigerParser_expr_return expr43;
    #undef	RETURN_TYPE_expr43
    #define	RETURN_TYPE_expr43 TigerParser_expr_return

    TigerParser_expr_return expr45;
    #undef	RETURN_TYPE_expr45
    #define	RETURN_TYPE_expr45 TigerParser_expr_return

    TigerParser_instruction_return instruction48;
    #undef	RETURN_TYPE_instruction48
    #define	RETURN_TYPE_instruction48 TigerParser_instruction_return

    TigerParser_instruction_return instruction50;
    #undef	RETURN_TYPE_instruction50
    #define	RETURN_TYPE_instruction50 TigerParser_instruction_return

    pANTLR3_BASE_TREE ID41_tree;
    pANTLR3_BASE_TREE char_literal42_tree;
    pANTLR3_BASE_TREE char_literal44_tree;
    pANTLR3_BASE_TREE char_literal46_tree;
    pANTLR3_BASE_TREE char_literal47_tree;
    pANTLR3_BASE_TREE char_literal49_tree;
    pANTLR3_BASE_TREE char_literal51_tree;
    pANTLR3_BASE_TREE STRING52_tree;
    pANTLR3_BASE_TREE INTEGER53_tree;
    pANTLR3_BASE_TREE char_literal54_tree;
    pANTLR3_BASE_TREE INTEGER55_tree;
    pANTLR3_BASE_TREE string_literal56_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_44;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_35;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_36;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_39;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_STRING;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_60;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_40;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_INTEGER;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_instruction;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_expr;
    /* Initialize rule variables
     */

    root_0 = NULL;

    ID41       = NULL;
    char_literal42       = NULL;
    char_literal44       = NULL;
    char_literal46       = NULL;
    char_literal47       = NULL;
    char_literal49       = NULL;
    char_literal51       = NULL;
    STRING52       = NULL;
    INTEGER53       = NULL;
    char_literal54       = NULL;
    INTEGER55       = NULL;
    string_literal56       = NULL;
    expr43.tree = NULL;

    expr45.tree = NULL;

    instruction48.tree = NULL;

    instruction50.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    ID41_tree   = NULL;
    char_literal42_tree   = NULL;
    char_literal44_tree   = NULL;
    char_literal46_tree   = NULL;
    char_literal47_tree   = NULL;
    char_literal49_tree   = NULL;
    char_literal51_tree   = NULL;
    STRING52_tree   = NULL;
    INTEGER53_tree   = NULL;
    char_literal54_tree   = NULL;
    INTEGER55_tree   = NULL;
    string_literal56_tree   = NULL;

    stream_44   = NULL;
    #define CREATE_stream_44  if (stream_44 == NULL) {stream_44 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 44"); } 
    stream_35   = NULL;
    #define CREATE_stream_35  if (stream_35 == NULL) {stream_35 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 35"); } 
    stream_36   = NULL;
    #define CREATE_stream_36  if (stream_36 == NULL) {stream_36 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 36"); } 
    stream_39   = NULL;
    #define CREATE_stream_39  if (stream_39 == NULL) {stream_39 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 39"); } 
    stream_STRING   = NULL;
    #define CREATE_stream_STRING  if (stream_STRING == NULL) {stream_STRING = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token STRING"); } 
    stream_60   = NULL;
    #define CREATE_stream_60  if (stream_60 == NULL) {stream_60 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 60"); } 
    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 
    stream_40   = NULL;
    #define CREATE_stream_40  if (stream_40 == NULL) {stream_40 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 40"); } 
    stream_INTEGER   = NULL;
    #define CREATE_stream_INTEGER  if (stream_INTEGER == NULL) {stream_INTEGER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token INTEGER"); } 
    stream_instruction   = NULL;
    #define CREATE_stream_instruction  if (stream_instruction == NULL) {stream_instruction = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule instruction"); }
    stream_expr   = NULL;
    #define CREATE_stream_expr  if (stream_expr == NULL) {stream_expr = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule expr"); }

    retval.tree  = NULL;

    {
        {
            //  ./src/Tiger.g:64:3: ( ID ( '(' ( expr ( ',' expr )* )? ')' )? -> ^( ID ( ^( ARGS ( expr )* ) )? ) | '(' instruction ( ';' instruction )* ')' -> ( instruction )+ | STRING -> ^( STR STRING ) | INTEGER -> ^( INT INTEGER ) | '-' INTEGER -> ^( NEG INTEGER ) | 'nil' -> ^( NIL ) )

            ANTLR3_UINT32 alt13;

            alt13=6;

            switch ( LA(1) )
            {
            case ID:
            	{
            		alt13=1;
            	}
                break;
            case 35:
            	{
            		alt13=2;
            	}
                break;
            case STRING:
            	{
            		alt13=3;
            	}
                break;
            case INTEGER:
            	{
            		alt13=4;
            	}
                break;
            case 40:
            	{
            		alt13=5;
            	}
                break;
            case 60:
            	{
            		alt13=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 13;
                EXCEPTION->state        = 0;


                goto ruleatomEx;

            }

            switch (alt13)
            {
        	case 1:
        	    // ./src/Tiger.g:64:5: ID ( '(' ( expr ( ',' expr )* )? ')' )?
        	    {
        	        ID41 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_atom1097);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, ID41, NULL);


        	        // ./src/Tiger.g:64:8: ( '(' ( expr ( ',' expr )* )? ')' )?
        	        {
        	            int alt11=2;
        	            switch ( LA(1) )
        	            {
        	                case 35:
        	                	{
        	                		alt11=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt11)
        	            {
        	        	case 1:
        	        	    // ./src/Tiger.g:64:9: '(' ( expr ( ',' expr )* )? ')'
        	        	    {
        	        	        char_literal42 = (pANTLR3_COMMON_TOKEN) MATCHT(35, &FOLLOW_35_in_atom1100);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_35; stream_35->add(stream_35, char_literal42, NULL);


        	        	        // ./src/Tiger.g:64:13: ( expr ( ',' expr )* )?
        	        	        {
        	        	            int alt10=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	                case ID:
        	        	                case INTEGER:
        	        	                case STRING:
        	        	                case 35:
        	        	                case 40:
        	        	                case 60:
        	        	                	{
        	        	                		alt10=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt10)
        	        	            {
        	        	        	case 1:
        	        	        	    // ./src/Tiger.g:64:14: expr ( ',' expr )*
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_expr_in_atom1103);
        	        	        	        expr43=expr(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleatomEx;
        	        	        	        }

        	        	        	        CREATE_stream_expr; stream_expr->add(stream_expr, expr43.tree, NULL);

        	        	        	        // ./src/Tiger.g:64:19: ( ',' expr )*

        	        	        	        for (;;)
        	        	        	        {
        	        	        	            int alt9=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	            case 39:
        	        	        	            	{
        	        	        	            		alt9=1;
        	        	        	            	}
        	        	        	                break;

        	        	        	            }

        	        	        	            switch (alt9)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // ./src/Tiger.g:64:20: ',' expr
        	        	        	        	    {
        	        	        	        	        char_literal44 = (pANTLR3_COMMON_TOKEN) MATCHT(39, &FOLLOW_39_in_atom1106);
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleatomEx;
        	        	        	        	        }
        	        	        	        	         
        	        	        	        	        CREATE_stream_39; stream_39->add(stream_39, char_literal44, NULL);


        	        	        	        	        FOLLOWPUSH(FOLLOW_expr_in_atom1108);
        	        	        	        	        expr45=expr(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleatomEx;
        	        	        	        	        }

        	        	        	        	        CREATE_stream_expr; stream_expr->add(stream_expr, expr45.tree, NULL);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	        	default:
        	        	        	        	    goto loop9;	/* break out of the loop */
        	        	        	        	    break;
        	        	        	            }
        	        	        	        }
        	        	        	        loop9: ; /* Jump out to here if this rule does not match */


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        char_literal46 = (pANTLR3_COMMON_TOKEN) MATCHT(36, &FOLLOW_36_in_atom1114);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_36; stream_36->add(stream_36, char_literal46, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        /* AST REWRITE
        	         * elements          : ID, expr
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 64:81: -> ^( ID ( ^( ARGS ( expr )* ) )? )
        	        	{
        	        	    // ./src/Tiger.g:64:84: ^( ID ( ^( ARGS ( expr )* ) )? )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        stream_ID == NULL ? NULL : stream_ID->nextNode(stream_ID)
        	        	        , root_1));

        	        	        // ./src/Tiger.g:64:89: ( ^( ARGS ( expr )* ) )?
        	        	        {
        	        	        	if ( (stream_expr != NULL && stream_expr->hasNext(stream_expr))  )
        	        	        	{
        	        	        		// ./src/Tiger.g:64:89: ^( ARGS ( expr )* )
        	        	        		{
        	        	        		    pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        		    root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        		    (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ARGS, (pANTLR3_UINT8)"ARGS")
        	        	        		    , root_2));

        	        	        		    // ./src/Tiger.g:64:96: ( expr )*
        	        	        		    {
        	        	        		    	while ( (stream_expr != NULL && stream_expr->hasNext(stream_expr))  )
        	        	        		    	{
        	        	        		    		ADAPTOR->addChild(ADAPTOR, root_2, stream_expr == NULL ? NULL : stream_expr->nextTree(stream_expr));

        	        	        		    	}
        	        	        		    	if (stream_expr != NULL) stream_expr->reset(stream_expr);

        	        	        		    }

        	        	        		    ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        		}

        	        	        	}
        	        	        	if ( stream_expr != NULL) stream_expr->reset(stream_expr);

        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // ./src/Tiger.g:66:5: '(' instruction ( ';' instruction )* ')'
        	    {
        	        char_literal47 = (pANTLR3_COMMON_TOKEN) MATCHT(35, &FOLLOW_35_in_atom1179);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_35; stream_35->add(stream_35, char_literal47, NULL);


        	        FOLLOWPUSH(FOLLOW_instruction_in_atom1181);
        	        instruction48=instruction(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }

        	        CREATE_stream_instruction; stream_instruction->add(stream_instruction, instruction48.tree, NULL);

        	        // ./src/Tiger.g:66:21: ( ';' instruction )*

        	        for (;;)
        	        {
        	            int alt12=2;
        	            switch ( LA(1) )
        	            {
        	            case 44:
        	            	{
        	            		alt12=1;
        	            	}
        	                break;

        	            }

        	            switch (alt12)
        	            {
        	        	case 1:
        	        	    // ./src/Tiger.g:66:22: ';' instruction
        	        	    {
        	        	        char_literal49 = (pANTLR3_COMMON_TOKEN) MATCHT(44, &FOLLOW_44_in_atom1184);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_44; stream_44->add(stream_44, char_literal49, NULL);


        	        	        FOLLOWPUSH(FOLLOW_instruction_in_atom1186);
        	        	        instruction50=instruction(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }

        	        	        CREATE_stream_instruction; stream_instruction->add(stream_instruction, instruction50.tree, NULL);

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop12;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop12: ; /* Jump out to here if this rule does not match */


        	        char_literal51 = (pANTLR3_COMMON_TOKEN) MATCHT(36, &FOLLOW_36_in_atom1190);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_36; stream_36->add(stream_36, char_literal51, NULL);


        	        /* AST REWRITE
        	         * elements          : instruction
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 66:81: -> ( instruction )+
        	        	{
        	        	    if ((stream_instruction == NULL || !stream_instruction->hasNext(stream_instruction))  )
        	        	    {
        	        	        CONSTRUCTEX();
        	        	        EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;
        	        	        EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;
        	        	    }
        	        	    else
        	        	    {
        	        	    	while ( (stream_instruction->hasNext(stream_instruction))  ) {
        	        	    		ADAPTOR->addChild(ADAPTOR, root_0, stream_instruction == NULL ? NULL : stream_instruction->nextTree(stream_instruction));

        	        	    	}
        	        	    	stream_instruction->reset(stream_instruction);

        	        	    }
        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 3:
        	    // ./src/Tiger.g:68:5: STRING
        	    {
        	        STRING52 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING, &FOLLOW_STRING_in_atom1239);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_STRING; stream_STRING->add(stream_STRING, STRING52, NULL);


        	        /* AST REWRITE
        	         * elements          : STRING
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 68:81: -> ^( STR STRING )
        	        	{
        	        	    // ./src/Tiger.g:68:84: ^( STR STRING )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, STR, (pANTLR3_UINT8)"STR")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_STRING == NULL ? NULL : stream_STRING->nextNode(stream_STRING)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 4:
        	    // ./src/Tiger.g:69:5: INTEGER
        	    {
        	        INTEGER53 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER, &FOLLOW_INTEGER_in_atom1322);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_INTEGER; stream_INTEGER->add(stream_INTEGER, INTEGER53, NULL);


        	        /* AST REWRITE
        	         * elements          : INTEGER
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 69:81: -> ^( INT INTEGER )
        	        	{
        	        	    // ./src/Tiger.g:69:84: ^( INT INTEGER )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, INT, (pANTLR3_UINT8)"INT")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_INTEGER == NULL ? NULL : stream_INTEGER->nextNode(stream_INTEGER)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 5:
        	    // ./src/Tiger.g:70:5: '-' INTEGER
        	    {
        	        char_literal54 = (pANTLR3_COMMON_TOKEN) MATCHT(40, &FOLLOW_40_in_atom1404);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_40; stream_40->add(stream_40, char_literal54, NULL);


        	        INTEGER55 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER, &FOLLOW_INTEGER_in_atom1406);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_INTEGER; stream_INTEGER->add(stream_INTEGER, INTEGER55, NULL);


        	        /* AST REWRITE
        	         * elements          : INTEGER
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 70:81: -> ^( NEG INTEGER )
        	        	{
        	        	    // ./src/Tiger.g:70:84: ^( NEG INTEGER )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NEG, (pANTLR3_UINT8)"NEG")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_INTEGER == NULL ? NULL : stream_INTEGER->nextNode(stream_INTEGER)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 6:
        	    // ./src/Tiger.g:71:5: 'nil'
        	    {
        	        string_literal56 = (pANTLR3_COMMON_TOKEN) MATCHT(60, &FOLLOW_60_in_atom1484);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_60; stream_60->add(stream_60, string_literal56, NULL);


        	        /* AST REWRITE
        	         * elements          : 
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 71:81: -> ^( NIL )
        	        	{
        	        	    // ./src/Tiger.g:71:84: ^( NIL )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NIL, (pANTLR3_UINT8)"NIL")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleatomEx; /* Prevent compiler warnings */
    ruleatomEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_44 != NULL) stream_44->free(stream_44);
        if (stream_35 != NULL) stream_35->free(stream_35);
        if (stream_36 != NULL) stream_36->free(stream_36);
        if (stream_39 != NULL) stream_39->free(stream_39);
        if (stream_STRING != NULL) stream_STRING->free(stream_STRING);
        if (stream_60 != NULL) stream_60->free(stream_60);
        if (stream_ID != NULL) stream_ID->free(stream_ID);
        if (stream_40 != NULL) stream_40->free(stream_40);
        if (stream_INTEGER != NULL) stream_INTEGER->free(stream_INTEGER);
        if (stream_instruction != NULL) stream_instruction->free(stream_instruction);
        if (stream_expr != NULL) stream_expr->free(stream_expr);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end atom */

/**
 * $ANTLR start expr
 * ./src/Tiger.g:76:1: expr : assignExpr ;
 */
static TigerParser_expr_return
expr(pTigerParser ctx)
{
    TigerParser_expr_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_assignExpr_return assignExpr57;
    #undef	RETURN_TYPE_assignExpr57
    #define	RETURN_TYPE_assignExpr57 TigerParser_assignExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    assignExpr57.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:76:6: ( assignExpr )
        // ./src/Tiger.g:76:8: assignExpr
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_assignExpr_in_expr1573);
            assignExpr57=assignExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, assignExpr57.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexprEx; /* Prevent compiler warnings */
    ruleexprEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end expr */

/**
 * $ANTLR start assignExpr
 * ./src/Tiger.g:78:1: assignExpr : logExpr ( assign ^ logExpr )* ;
 */
static TigerParser_assignExpr_return
assignExpr(pTigerParser ctx)
{
    TigerParser_assignExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_logExpr_return logExpr58;
    #undef	RETURN_TYPE_logExpr58
    #define	RETURN_TYPE_logExpr58 TigerParser_logExpr_return

    TigerParser_assign_return assign59;
    #undef	RETURN_TYPE_assign59
    #define	RETURN_TYPE_assign59 TigerParser_assign_return

    TigerParser_logExpr_return logExpr60;
    #undef	RETURN_TYPE_logExpr60
    #define	RETURN_TYPE_logExpr60 TigerParser_logExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    logExpr58.tree = NULL;

    assign59.tree = NULL;

    logExpr60.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:78:13: ( logExpr ( assign ^ logExpr )* )
        // ./src/Tiger.g:78:15: logExpr ( assign ^ logExpr )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_logExpr_in_assignExpr1583);
            logExpr58=logExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleassignExprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, logExpr58.tree);

            // ./src/Tiger.g:78:27: ( assign ^ logExpr )*

            for (;;)
            {
                int alt14=2;
                switch ( LA(1) )
                {
                case 43:
                	{
                		alt14=1;
                	}
                    break;

                }

                switch (alt14)
                {
            	case 1:
            	    // ./src/Tiger.g:78:30: assign ^ logExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_assign_in_assignExpr1592);
            	        assign59=assign(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleassignExprEx;
            	        }

            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, assign59.tree, root_0));

            	        FOLLOWPUSH(FOLLOW_logExpr_in_assignExpr1599);
            	        logExpr60=logExpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleassignExprEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, logExpr60.tree);

            	    }
            	    break;

            	default:
            	    goto loop14;	/* break out of the loop */
            	    break;
                }
            }
            loop14: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleassignExprEx; /* Prevent compiler warnings */
    ruleassignExprEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end assignExpr */

/**
 * $ANTLR start logExpr
 * ./src/Tiger.g:79:1: logExpr : andExpr ( or ^ andExpr )* ;
 */
static TigerParser_logExpr_return
logExpr(pTigerParser ctx)
{
    TigerParser_logExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_andExpr_return andExpr61;
    #undef	RETURN_TYPE_andExpr61
    #define	RETURN_TYPE_andExpr61 TigerParser_andExpr_return

    TigerParser_or_return or62;
    #undef	RETURN_TYPE_or62
    #define	RETURN_TYPE_or62 TigerParser_or_return

    TigerParser_andExpr_return andExpr63;
    #undef	RETURN_TYPE_andExpr63
    #define	RETURN_TYPE_andExpr63 TigerParser_andExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    andExpr61.tree = NULL;

    or62.tree = NULL;

    andExpr63.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:79:13: ( andExpr ( or ^ andExpr )* )
        // ./src/Tiger.g:79:15: andExpr ( or ^ andExpr )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_andExpr_in_logExpr1613);
            andExpr61=andExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelogExprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, andExpr61.tree);

            // ./src/Tiger.g:79:27: ( or ^ andExpr )*

            for (;;)
            {
                int alt15=2;
                switch ( LA(1) )
                {
                case 66:
                	{
                		alt15=1;
                	}
                    break;

                }

                switch (alt15)
                {
            	case 1:
            	    // ./src/Tiger.g:79:34: or ^ andExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_or_in_logExpr1626);
            	        or62=or(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelogExprEx;
            	        }

            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, or62.tree, root_0));

            	        FOLLOWPUSH(FOLLOW_andExpr_in_logExpr1633);
            	        andExpr63=andExpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelogExprEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, andExpr63.tree);

            	    }
            	    break;

            	default:
            	    goto loop15;	/* break out of the loop */
            	    break;
                }
            }
            loop15: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulelogExprEx; /* Prevent compiler warnings */
    rulelogExprEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end logExpr */

/**
 * $ANTLR start andExpr
 * ./src/Tiger.g:80:1: andExpr : compExpr ( and ^ compExpr )* ;
 */
static TigerParser_andExpr_return
andExpr(pTigerParser ctx)
{
    TigerParser_andExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_compExpr_return compExpr64;
    #undef	RETURN_TYPE_compExpr64
    #define	RETURN_TYPE_compExpr64 TigerParser_compExpr_return

    TigerParser_and_return and65;
    #undef	RETURN_TYPE_and65
    #define	RETURN_TYPE_and65 TigerParser_and_return

    TigerParser_compExpr_return compExpr66;
    #undef	RETURN_TYPE_compExpr66
    #define	RETURN_TYPE_compExpr66 TigerParser_compExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    compExpr64.tree = NULL;

    and65.tree = NULL;

    compExpr66.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:80:13: ( compExpr ( and ^ compExpr )* )
        // ./src/Tiger.g:80:15: compExpr ( and ^ compExpr )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_compExpr_in_andExpr1647);
            compExpr64=compExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleandExprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, compExpr64.tree);

            // ./src/Tiger.g:80:27: ( and ^ compExpr )*

            for (;;)
            {
                int alt16=2;
                switch ( LA(1) )
                {
                case 34:
                	{
                		alt16=1;
                	}
                    break;

                }

                switch (alt16)
                {
            	case 1:
            	    // ./src/Tiger.g:80:33: and ^ compExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_and_in_andExpr1658);
            	        and65=and(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleandExprEx;
            	        }

            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, and65.tree, root_0));

            	        FOLLOWPUSH(FOLLOW_compExpr_in_andExpr1664);
            	        compExpr66=compExpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleandExprEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, compExpr66.tree);

            	    }
            	    break;

            	default:
            	    goto loop16;	/* break out of the loop */
            	    break;
                }
            }
            loop16: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleandExprEx; /* Prevent compiler warnings */
    ruleandExprEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end andExpr */

/**
 * $ANTLR start compExpr
 * ./src/Tiger.g:81:1: compExpr : addMinExpr ( comp ^ addMinExpr )? ;
 */
static TigerParser_compExpr_return
compExpr(pTigerParser ctx)
{
    TigerParser_compExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_addMinExpr_return addMinExpr67;
    #undef	RETURN_TYPE_addMinExpr67
    #define	RETURN_TYPE_addMinExpr67 TigerParser_addMinExpr_return

    TigerParser_comp_return comp68;
    #undef	RETURN_TYPE_comp68
    #define	RETURN_TYPE_comp68 TigerParser_comp_return

    TigerParser_addMinExpr_return addMinExpr69;
    #undef	RETURN_TYPE_addMinExpr69
    #define	RETURN_TYPE_addMinExpr69 TigerParser_addMinExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    addMinExpr67.tree = NULL;

    comp68.tree = NULL;

    addMinExpr69.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:81:13: ( addMinExpr ( comp ^ addMinExpr )? )
        // ./src/Tiger.g:81:15: addMinExpr ( comp ^ addMinExpr )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_addMinExpr_in_compExpr1677);
            addMinExpr67=addMinExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecompExprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, addMinExpr67.tree);

            // ./src/Tiger.g:81:27: ( comp ^ addMinExpr )?
            {
                int alt17=2;
                switch ( LA(1) )
                {
                    case 45:
                    case 46:
                    case 47:
                    case 48:
                    case 49:
                    case 50:
                    	{
                    		alt17=1;
                    	}
                        break;
                }

                switch (alt17)
                {
            	case 1:
            	    // ./src/Tiger.g:81:32: comp ^ addMinExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_comp_in_compExpr1685);
            	        comp68=comp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecompExprEx;
            	        }

            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, comp68.tree, root_0));

            	        FOLLOWPUSH(FOLLOW_addMinExpr_in_compExpr1689);
            	        addMinExpr69=addMinExpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecompExprEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, addMinExpr69.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulecompExprEx; /* Prevent compiler warnings */
    rulecompExprEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end compExpr */

/**
 * $ANTLR start addMinExpr
 * ./src/Tiger.g:82:1: addMinExpr : multDivExpr ( addMin ^ multDivExpr )* ;
 */
static TigerParser_addMinExpr_return
addMinExpr(pTigerParser ctx)
{
    TigerParser_addMinExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_multDivExpr_return multDivExpr70;
    #undef	RETURN_TYPE_multDivExpr70
    #define	RETURN_TYPE_multDivExpr70 TigerParser_multDivExpr_return

    TigerParser_addMin_return addMin71;
    #undef	RETURN_TYPE_addMin71
    #define	RETURN_TYPE_addMin71 TigerParser_addMin_return

    TigerParser_multDivExpr_return multDivExpr72;
    #undef	RETURN_TYPE_multDivExpr72
    #define	RETURN_TYPE_multDivExpr72 TigerParser_multDivExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    multDivExpr70.tree = NULL;

    addMin71.tree = NULL;

    multDivExpr72.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:82:13: ( multDivExpr ( addMin ^ multDivExpr )* )
        // ./src/Tiger.g:82:15: multDivExpr ( addMin ^ multDivExpr )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_multDivExpr_in_addMinExpr1700);
            multDivExpr70=multDivExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaddMinExprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, multDivExpr70.tree);

            // ./src/Tiger.g:82:27: ( addMin ^ multDivExpr )*

            for (;;)
            {
                int alt18=2;
                switch ( LA(1) )
                {
                case 38:
                case 40:
                	{
                		alt18=1;
                	}
                    break;

                }

                switch (alt18)
                {
            	case 1:
            	    // ./src/Tiger.g:82:30: addMin ^ multDivExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_addMin_in_addMinExpr1705);
            	        addMin71=addMin(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaddMinExprEx;
            	        }

            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, addMin71.tree, root_0));

            	        FOLLOWPUSH(FOLLOW_multDivExpr_in_addMinExpr1708);
            	        multDivExpr72=multDivExpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaddMinExprEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, multDivExpr72.tree);

            	    }
            	    break;

            	default:
            	    goto loop18;	/* break out of the loop */
            	    break;
                }
            }
            loop18: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleaddMinExprEx; /* Prevent compiler warnings */
    ruleaddMinExprEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end addMinExpr */

/**
 * $ANTLR start multDivExpr
 * ./src/Tiger.g:83:1: multDivExpr : atom ( multDiv ^ atom )* ;
 */
static TigerParser_multDivExpr_return
multDivExpr(pTigerParser ctx)
{
    TigerParser_multDivExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_atom_return atom73;
    #undef	RETURN_TYPE_atom73
    #define	RETURN_TYPE_atom73 TigerParser_atom_return

    TigerParser_multDiv_return multDiv74;
    #undef	RETURN_TYPE_multDiv74
    #define	RETURN_TYPE_multDiv74 TigerParser_multDiv_return

    TigerParser_atom_return atom75;
    #undef	RETURN_TYPE_atom75
    #define	RETURN_TYPE_atom75 TigerParser_atom_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    atom73.tree = NULL;

    multDiv74.tree = NULL;

    atom75.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:83:13: ( atom ( multDiv ^ atom )* )
        // ./src/Tiger.g:83:15: atom ( multDiv ^ atom )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_atom_in_multDivExpr1718);
            atom73=atom(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemultDivExprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, atom73.tree);

            // ./src/Tiger.g:83:27: ( multDiv ^ atom )*

            for (;;)
            {
                int alt19=2;
                switch ( LA(1) )
                {
                case 37:
                case 41:
                	{
                		alt19=1;
                	}
                    break;

                }

                switch (alt19)
                {
            	case 1:
            	    // ./src/Tiger.g:83:29: multDiv ^ atom
            	    {
            	        FOLLOWPUSH(FOLLOW_multDiv_in_multDivExpr1729);
            	        multDiv74=multDiv(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemultDivExprEx;
            	        }

            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, multDiv74.tree, root_0));

            	        FOLLOWPUSH(FOLLOW_atom_in_multDivExpr1739);
            	        atom75=atom(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemultDivExprEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, atom75.tree);

            	    }
            	    break;

            	default:
            	    goto loop19;	/* break out of the loop */
            	    break;
                }
            }
            loop19: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemultDivExprEx; /* Prevent compiler warnings */
    rulemultDivExprEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end multDivExpr */

/**
 * $ANTLR start addMin
 * ./src/Tiger.g:86:2: addMin : ( '+' | '-' );
 */
static TigerParser_addMin_return
addMin(pTigerParser ctx)
{
    TigerParser_addMin_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set76;

    pANTLR3_BASE_TREE set76_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set76       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set76_tree   = NULL;


    retval.tree  = NULL;

    {
        // ./src/Tiger.g:86:9: ( '+' | '-' )
        // ./src/Tiger.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set76=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == 38 || LA(1) == 40 )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set76))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleaddMinEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleaddMinEx; /* Prevent compiler warnings */
    ruleaddMinEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end addMin */

/**
 * $ANTLR start multDiv
 * ./src/Tiger.g:87:1: multDiv : ( '*' | '/' );
 */
static TigerParser_multDiv_return
multDiv(pTigerParser ctx)
{
    TigerParser_multDiv_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set77;

    pANTLR3_BASE_TREE set77_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set77       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set77_tree   = NULL;


    retval.tree  = NULL;

    {
        // ./src/Tiger.g:87:9: ( '*' | '/' )
        // ./src/Tiger.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set77=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == 37 || LA(1) == 41 )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set77))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulemultDivEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemultDivEx; /* Prevent compiler warnings */
    rulemultDivEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end multDiv */

/**
 * $ANTLR start comp
 * ./src/Tiger.g:88:4: comp : ( '<' | '>' | '<=' | '>=' | '=' | '<>' );
 */
static TigerParser_comp_return
comp(pTigerParser ctx)
{
    TigerParser_comp_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set78;

    pANTLR3_BASE_TREE set78_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set78       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set78_tree   = NULL;


    retval.tree  = NULL;

    {
        // ./src/Tiger.g:88:9: ( '<' | '>' | '<=' | '>=' | '=' | '<>' )
        // ./src/Tiger.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set78=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( ((LA(1) >= 45) && (LA(1) <= 50)) )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set78))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulecompEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecompEx; /* Prevent compiler warnings */
    rulecompEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end comp */

/**
 * $ANTLR start and
 * ./src/Tiger.g:89:5: and : '&' ;
 */
static TigerParser_and_return
and(pTigerParser ctx)
{
    TigerParser_and_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal79;

    pANTLR3_BASE_TREE char_literal79_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal79       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal79_tree   = NULL;


    retval.tree  = NULL;

    {
        // ./src/Tiger.g:89:9: ( '&' )
        // ./src/Tiger.g:89:11: '&'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            char_literal79 = (pANTLR3_COMMON_TOKEN) MATCHT(34, &FOLLOW_34_in_and1797);
            if  (HASEXCEPTION())
            {
                goto ruleandEx;
            }

            char_literal79_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal79));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal79_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleandEx; /* Prevent compiler warnings */
    ruleandEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end and */

/**
 * $ANTLR start or
 * ./src/Tiger.g:90:5: or : '|' ;
 */
static TigerParser_or_return
or(pTigerParser ctx)
{
    TigerParser_or_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal80;

    pANTLR3_BASE_TREE char_literal80_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal80       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal80_tree   = NULL;


    retval.tree  = NULL;

    {
        // ./src/Tiger.g:90:9: ( '|' )
        // ./src/Tiger.g:90:11: '|'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            char_literal80 = (pANTLR3_COMMON_TOKEN) MATCHT(66, &FOLLOW_66_in_or1810);
            if  (HASEXCEPTION())
            {
                goto ruleorEx;
            }

            char_literal80_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal80));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal80_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleorEx; /* Prevent compiler warnings */
    ruleorEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end or */

/**
 * $ANTLR start assign
 * ./src/Tiger.g:91:1: assign : ':=' ;
 */
static TigerParser_assign_return
assign(pTigerParser ctx)
{
    TigerParser_assign_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal81;

    pANTLR3_BASE_TREE string_literal81_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal81       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal81_tree   = NULL;


    retval.tree  = NULL;

    {
        // ./src/Tiger.g:91:9: ( ':=' )
        // ./src/Tiger.g:91:11: ':='
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal81 = (pANTLR3_COMMON_TOKEN) MATCHT(43, &FOLLOW_43_in_assign1819);
            if  (HASEXCEPTION())
            {
                goto ruleassignEx;
            }

            string_literal81_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal81));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal81_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleassignEx; /* Prevent compiler warnings */
    ruleassignEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end assign */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
