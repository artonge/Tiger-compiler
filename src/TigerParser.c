/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : ./src/Tiger.g
 *     -                            On : 2016-04-24 14:03:37
 *     -                for the parser : TigerParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "TigerParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pTigerParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pTigerParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pTigerParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pTigerParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   TigerParserTokenNames[61+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "ADD",
        (pANTLR3_UINT8) "AND",
        (pANTLR3_UINT8) "ARGS",
        (pANTLR3_UINT8) "ASSIGNE",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "COMP",
        (pANTLR3_UINT8) "DECLARATIONS",
        (pANTLR3_UINT8) "EXPR",
        (pANTLR3_UINT8) "FOR",
        (pANTLR3_UINT8) "FUNC_DECLARATION",
        (pANTLR3_UINT8) "ID",
        (pANTLR3_UINT8) "IF",
        (pANTLR3_UINT8) "INSTRUCTIONS",
        (pANTLR3_UINT8) "INT",
        (pANTLR3_UINT8) "INTEGER",
        (pANTLR3_UINT8) "LET",
        (pANTLR3_UINT8) "LETTER",
        (pANTLR3_UINT8) "MULT",
        (pANTLR3_UINT8) "NEG",
        (pANTLR3_UINT8) "NIL",
        (pANTLR3_UINT8) "OR",
        (pANTLR3_UINT8) "PARAM",
        (pANTLR3_UINT8) "PARAMS",
        (pANTLR3_UINT8) "STR",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "TYPE",
        (pANTLR3_UINT8) "VAR_DECLARATION",
        (pANTLR3_UINT8) "WHILE",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "'&'",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "'*'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'-'",
        (pANTLR3_UINT8) "'/'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "':='",
        (pANTLR3_UINT8) "';'",
        (pANTLR3_UINT8) "'<'",
        (pANTLR3_UINT8) "'<='",
        (pANTLR3_UINT8) "'<>'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'>'",
        (pANTLR3_UINT8) "'>='",
        (pANTLR3_UINT8) "'break'",
        (pANTLR3_UINT8) "'do'",
        (pANTLR3_UINT8) "'else'",
        (pANTLR3_UINT8) "'end'",
        (pANTLR3_UINT8) "'for'",
        (pANTLR3_UINT8) "'function'",
        (pANTLR3_UINT8) "'if'",
        (pANTLR3_UINT8) "'in'",
        (pANTLR3_UINT8) "'let'",
        (pANTLR3_UINT8) "'nil'",
        (pANTLR3_UINT8) "'then'",
        (pANTLR3_UINT8) "'to'",
        (pANTLR3_UINT8) "'var'",
        (pANTLR3_UINT8) "'while'",
        (pANTLR3_UINT8) "'|'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 TigerParser_program_return
	program    (pTigerParser ctx);
static 
 TigerParser_instructions_return
	instructions    (pTigerParser ctx);
static 
 TigerParser_declaration_return
	declaration    (pTigerParser ctx);
static 
 TigerParser_params_return
	params    (pTigerParser ctx);
static 
 TigerParser_param_return
	param    (pTigerParser ctx);
static 
 TigerParser_instruction_return
	instruction    (pTigerParser ctx);
static 
 TigerParser_atom_return
	atom    (pTigerParser ctx);
static 
 TigerParser_expr_return
	expr    (pTigerParser ctx);
static 
 TigerParser_assignExpr_return
	assignExpr    (pTigerParser ctx);
static 
 TigerParser_logExpr_return
	logExpr    (pTigerParser ctx);
static 
 TigerParser_andExpr_return
	andExpr    (pTigerParser ctx);
static 
 TigerParser_compExpr_return
	compExpr    (pTigerParser ctx);
static 
 TigerParser_addMinExpr_return
	addMinExpr    (pTigerParser ctx);
static 
 TigerParser_multDivExpr_return
	multDivExpr    (pTigerParser ctx);
static 
 TigerParser_addMin_return
	addMin    (pTigerParser ctx);
static 
 TigerParser_multDiv_return
	multDiv    (pTigerParser ctx);
static 
 TigerParser_comp_return
	comp    (pTigerParser ctx);
static 
 TigerParser_and_return
	and    (pTigerParser ctx);
static 
 TigerParser_or_return
	or    (pTigerParser ctx);
static 
 TigerParser_assign_return
	assign    (pTigerParser ctx);
static void	TigerParserFree(pTigerParser ctx);
static void     TigerParserReset (pTigerParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "./src/Tiger.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new TigerParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pTigerParser
TigerParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return TigerParserNewSSD(instream, NULL);
}

/** \brief Create a new TigerParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pTigerParser
TigerParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pTigerParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pTigerParser) ANTLR3_CALLOC(1, sizeof(TigerParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in TigerParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our TigerParser interface
     */
    ctx->program	= program;
    ctx->instructions	= instructions;
    ctx->declaration	= declaration;
    ctx->params	= params;
    ctx->param	= param;
    ctx->instruction	= instruction;
    ctx->atom	= atom;
    ctx->expr	= expr;
    ctx->assignExpr	= assignExpr;
    ctx->logExpr	= logExpr;
    ctx->andExpr	= andExpr;
    ctx->compExpr	= compExpr;
    ctx->addMinExpr	= addMinExpr;
    ctx->multDivExpr	= multDivExpr;
    ctx->addMin	= addMin;
    ctx->multDiv	= multDiv;
    ctx->comp	= comp;
    ctx->and	= and;
    ctx->or	= or;
    ctx->assign	= assign;
    ctx->free			= TigerParserFree;
    ctx->reset			= TigerParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);

ctx->vectors	= antlr3VectorFactoryNew(0);
    /* Install the token table
     */
    PSRSTATE->tokenNames   = TigerParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
TigerParserReset (pTigerParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 TigerParserFree(pTigerParser ctx)
 {
    /* Free any scope memory
     */

ctx->vectors->close(ctx->vectors);
/* We created the adaptor so we must free it
 */
ADAPTOR->free(ADAPTOR);
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return TigerParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_program249  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_program249_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_program249	= { FOLLOW_instructions_in_program249_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instruction_in_instructions260  */
static	ANTLR3_BITWORD FOLLOW_instruction_in_instructions260_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instruction_in_instructions260	= { FOLLOW_instruction_in_instructions260_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_62_in_declaration347  */
static	ANTLR3_BITWORD FOLLOW_62_in_declaration347_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_62_in_declaration347	= { FOLLOW_62_in_declaration347_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_declaration351  */
static	ANTLR3_BITWORD FOLLOW_ID_in_declaration351_bits[]	= { ANTLR3_UINT64_LIT(0x0000060000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_declaration351	= { FOLLOW_ID_in_declaration351_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_declaration354  */
static	ANTLR3_BITWORD FOLLOW_41_in_declaration354_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_declaration354	= { FOLLOW_41_in_declaration354_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_declaration358  */
static	ANTLR3_BITWORD FOLLOW_ID_in_declaration358_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_declaration358	= { FOLLOW_ID_in_declaration358_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_declaration362  */
static	ANTLR3_BITWORD FOLLOW_42_in_declaration362_bits[]	= { ANTLR3_UINT64_LIT(0x0800008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_declaration362	= { FOLLOW_42_in_declaration362_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_declaration364  */
static	ANTLR3_BITWORD FOLLOW_expr_in_declaration364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_declaration364	= { FOLLOW_expr_in_declaration364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_55_in_declaration422  */
static	ANTLR3_BITWORD FOLLOW_55_in_declaration422_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_55_in_declaration422	= { FOLLOW_55_in_declaration422_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_declaration426  */
static	ANTLR3_BITWORD FOLLOW_ID_in_declaration426_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_declaration426	= { FOLLOW_ID_in_declaration426_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_params_in_declaration428  */
static	ANTLR3_BITWORD FOLLOW_params_in_declaration428_bits[]	= { ANTLR3_UINT64_LIT(0x0000820000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_params_in_declaration428	= { FOLLOW_params_in_declaration428_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_declaration431  */
static	ANTLR3_BITWORD FOLLOW_41_in_declaration431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_declaration431	= { FOLLOW_41_in_declaration431_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_declaration435  */
static	ANTLR3_BITWORD FOLLOW_ID_in_declaration435_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_declaration435	= { FOLLOW_ID_in_declaration435_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_47_in_declaration439  */
static	ANTLR3_BITWORD FOLLOW_47_in_declaration439_bits[]	= { ANTLR3_UINT64_LIT(0x8D44008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_47_in_declaration439	= { FOLLOW_47_in_declaration439_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_declaration441  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_declaration441_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_declaration441	= { FOLLOW_instructions_in_declaration441_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_params486  */
static	ANTLR3_BITWORD FOLLOW_34_in_params486_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800004000) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_params486	= { FOLLOW_34_in_params486_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_in_params490  */
static	ANTLR3_BITWORD FOLLOW_param_in_params490_bits[]	= { ANTLR3_UINT64_LIT(0x0000004800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_param_in_params490	= { FOLLOW_param_in_params490_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_params493  */
static	ANTLR3_BITWORD FOLLOW_38_in_params493_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_params493	= { FOLLOW_38_in_params493_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_param_in_params495  */
static	ANTLR3_BITWORD FOLLOW_param_in_params495_bits[]	= { ANTLR3_UINT64_LIT(0x0000004800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_param_in_params495	= { FOLLOW_param_in_params495_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_params501  */
static	ANTLR3_BITWORD FOLLOW_35_in_params501_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_params501	= { FOLLOW_35_in_params501_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_param569  */
static	ANTLR3_BITWORD FOLLOW_ID_in_param569_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_param569	= { FOLLOW_ID_in_param569_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_param571  */
static	ANTLR3_BITWORD FOLLOW_41_in_param571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_param571	= { FOLLOW_41_in_param571_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_param575  */
static	ANTLR3_BITWORD FOLLOW_ID_in_param575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_param575	= { FOLLOW_ID_in_param575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_58_in_instruction658  */
static	ANTLR3_BITWORD FOLLOW_58_in_instruction658_bits[]	= { ANTLR3_UINT64_LIT(0x4080000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_58_in_instruction658	= { FOLLOW_58_in_instruction658_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_in_instruction660  */
static	ANTLR3_BITWORD FOLLOW_declaration_in_instruction660_bits[]	= { ANTLR3_UINT64_LIT(0x4280000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_in_instruction660	= { FOLLOW_declaration_in_instruction660_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_57_in_instruction663  */
static	ANTLR3_BITWORD FOLLOW_57_in_instruction663_bits[]	= { ANTLR3_UINT64_LIT(0x8D44008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_57_in_instruction663	= { FOLLOW_57_in_instruction663_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction665  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction665_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction665	= { FOLLOW_instructions_in_instruction665_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_53_in_instruction667  */
static	ANTLR3_BITWORD FOLLOW_53_in_instruction667_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_53_in_instruction667	= { FOLLOW_53_in_instruction667_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_instruction722  */
static	ANTLR3_BITWORD FOLLOW_expr_in_instruction722_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_instruction722	= { FOLLOW_expr_in_instruction722_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_instruction729  */
static	ANTLR3_BITWORD FOLLOW_56_in_instruction729_bits[]	= { ANTLR3_UINT64_LIT(0x0800008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_56_in_instruction729	= { FOLLOW_56_in_instruction729_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_instruction731  */
static	ANTLR3_BITWORD FOLLOW_expr_in_instruction731_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_instruction731	= { FOLLOW_expr_in_instruction731_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_instruction733  */
static	ANTLR3_BITWORD FOLLOW_60_in_instruction733_bits[]	= { ANTLR3_UINT64_LIT(0x8D44008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_60_in_instruction733	= { FOLLOW_60_in_instruction733_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction737  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction737_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction737	= { FOLLOW_instructions_in_instruction737_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_52_in_instruction753  */
static	ANTLR3_BITWORD FOLLOW_52_in_instruction753_bits[]	= { ANTLR3_UINT64_LIT(0x8D44008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_52_in_instruction753	= { FOLLOW_52_in_instruction753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction757  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction757_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction757	= { FOLLOW_instructions_in_instruction757_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_63_in_instruction805  */
static	ANTLR3_BITWORD FOLLOW_63_in_instruction805_bits[]	= { ANTLR3_UINT64_LIT(0x0800008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_63_in_instruction805	= { FOLLOW_63_in_instruction805_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_instruction807  */
static	ANTLR3_BITWORD FOLLOW_expr_in_instruction807_bits[]	= { ANTLR3_UINT64_LIT(0x0008000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_instruction807	= { FOLLOW_expr_in_instruction807_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_51_in_instruction809  */
static	ANTLR3_BITWORD FOLLOW_51_in_instruction809_bits[]	= { ANTLR3_UINT64_LIT(0x8D44008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_51_in_instruction809	= { FOLLOW_51_in_instruction809_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction811  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction811_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction811	= { FOLLOW_instructions_in_instruction811_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_instruction872  */
static	ANTLR3_BITWORD FOLLOW_54_in_instruction872_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_54_in_instruction872	= { FOLLOW_54_in_instruction872_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_instruction874  */
static	ANTLR3_BITWORD FOLLOW_ID_in_instruction874_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_instruction874	= { FOLLOW_ID_in_instruction874_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_instruction876  */
static	ANTLR3_BITWORD FOLLOW_42_in_instruction876_bits[]	= { ANTLR3_UINT64_LIT(0x0800008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_instruction876	= { FOLLOW_42_in_instruction876_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_instruction880  */
static	ANTLR3_BITWORD FOLLOW_expr_in_instruction880_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_instruction880	= { FOLLOW_expr_in_instruction880_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_61_in_instruction882  */
static	ANTLR3_BITWORD FOLLOW_61_in_instruction882_bits[]	= { ANTLR3_UINT64_LIT(0x0800008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_61_in_instruction882	= { FOLLOW_61_in_instruction882_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_instruction886  */
static	ANTLR3_BITWORD FOLLOW_expr_in_instruction886_bits[]	= { ANTLR3_UINT64_LIT(0x0008000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_instruction886	= { FOLLOW_expr_in_instruction886_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_51_in_instruction888  */
static	ANTLR3_BITWORD FOLLOW_51_in_instruction888_bits[]	= { ANTLR3_UINT64_LIT(0x8D44008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_51_in_instruction888	= { FOLLOW_51_in_instruction888_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instructions_in_instruction890  */
static	ANTLR3_BITWORD FOLLOW_instructions_in_instruction890_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_instructions_in_instruction890	= { FOLLOW_instructions_in_instruction890_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_50_in_instruction935  */
static	ANTLR3_BITWORD FOLLOW_50_in_instruction935_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_50_in_instruction935	= { FOLLOW_50_in_instruction935_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ID_in_atom948  */
static	ANTLR3_BITWORD FOLLOW_ID_in_atom948_bits[]	= { ANTLR3_UINT64_LIT(0x0000000400000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ID_in_atom948	= { FOLLOW_ID_in_atom948_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_atom951  */
static	ANTLR3_BITWORD FOLLOW_34_in_atom951_bits[]	= { ANTLR3_UINT64_LIT(0x0800008C10044000) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_atom951	= { FOLLOW_34_in_atom951_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_atom954  */
static	ANTLR3_BITWORD FOLLOW_expr_in_atom954_bits[]	= { ANTLR3_UINT64_LIT(0x0000004800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_atom954	= { FOLLOW_expr_in_atom954_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_atom957  */
static	ANTLR3_BITWORD FOLLOW_38_in_atom957_bits[]	= { ANTLR3_UINT64_LIT(0x0800008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_atom957	= { FOLLOW_38_in_atom957_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expr_in_atom959  */
static	ANTLR3_BITWORD FOLLOW_expr_in_atom959_bits[]	= { ANTLR3_UINT64_LIT(0x0000004800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expr_in_atom959	= { FOLLOW_expr_in_atom959_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_atom965  */
static	ANTLR3_BITWORD FOLLOW_35_in_atom965_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_atom965	= { FOLLOW_35_in_atom965_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_34_in_atom1030  */
static	ANTLR3_BITWORD FOLLOW_34_in_atom1030_bits[]	= { ANTLR3_UINT64_LIT(0x8D44008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_34_in_atom1030	= { FOLLOW_34_in_atom1030_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instruction_in_atom1032  */
static	ANTLR3_BITWORD FOLLOW_instruction_in_atom1032_bits[]	= { ANTLR3_UINT64_LIT(0x0000080800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_instruction_in_atom1032	= { FOLLOW_instruction_in_atom1032_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_atom1035  */
static	ANTLR3_BITWORD FOLLOW_43_in_atom1035_bits[]	= { ANTLR3_UINT64_LIT(0x8D44008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_atom1035	= { FOLLOW_43_in_atom1035_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_instruction_in_atom1037  */
static	ANTLR3_BITWORD FOLLOW_instruction_in_atom1037_bits[]	= { ANTLR3_UINT64_LIT(0x0000080800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_instruction_in_atom1037	= { FOLLOW_instruction_in_atom1037_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_35_in_atom1041  */
static	ANTLR3_BITWORD FOLLOW_35_in_atom1041_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_35_in_atom1041	= { FOLLOW_35_in_atom1041_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_atom1090  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_atom1090_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_atom1090	= { FOLLOW_STRING_in_atom1090_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_in_atom1173  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_in_atom1173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_in_atom1173	= { FOLLOW_INTEGER_in_atom1173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_atom1255  */
static	ANTLR3_BITWORD FOLLOW_39_in_atom1255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_atom1255	= { FOLLOW_39_in_atom1255_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTEGER_in_atom1257  */
static	ANTLR3_BITWORD FOLLOW_INTEGER_in_atom1257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTEGER_in_atom1257	= { FOLLOW_INTEGER_in_atom1257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_59_in_atom1335  */
static	ANTLR3_BITWORD FOLLOW_59_in_atom1335_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_59_in_atom1335	= { FOLLOW_59_in_atom1335_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignExpr_in_expr1424  */
static	ANTLR3_BITWORD FOLLOW_assignExpr_in_expr1424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_assignExpr_in_expr1424	= { FOLLOW_assignExpr_in_expr1424_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logExpr_in_assignExpr1434  */
static	ANTLR3_BITWORD FOLLOW_logExpr_in_assignExpr1434_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logExpr_in_assignExpr1434	= { FOLLOW_logExpr_in_assignExpr1434_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_assign_in_assignExpr1443  */
static	ANTLR3_BITWORD FOLLOW_assign_in_assignExpr1443_bits[]	= { ANTLR3_UINT64_LIT(0x0800008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_assign_in_assignExpr1443	= { FOLLOW_assign_in_assignExpr1443_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_logExpr_in_assignExpr1450  */
static	ANTLR3_BITWORD FOLLOW_logExpr_in_assignExpr1450_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_logExpr_in_assignExpr1450	= { FOLLOW_logExpr_in_assignExpr1450_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_andExpr_in_logExpr1464  */
static	ANTLR3_BITWORD FOLLOW_andExpr_in_logExpr1464_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_andExpr_in_logExpr1464	= { FOLLOW_andExpr_in_logExpr1464_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_or_in_logExpr1477  */
static	ANTLR3_BITWORD FOLLOW_or_in_logExpr1477_bits[]	= { ANTLR3_UINT64_LIT(0x0800008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_or_in_logExpr1477	= { FOLLOW_or_in_logExpr1477_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_andExpr_in_logExpr1484  */
static	ANTLR3_BITWORD FOLLOW_andExpr_in_logExpr1484_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_andExpr_in_logExpr1484	= { FOLLOW_andExpr_in_logExpr1484_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compExpr_in_andExpr1498  */
static	ANTLR3_BITWORD FOLLOW_compExpr_in_andExpr1498_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000002) };
static  ANTLR3_BITSET_LIST FOLLOW_compExpr_in_andExpr1498	= { FOLLOW_compExpr_in_andExpr1498_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_and_in_andExpr1509  */
static	ANTLR3_BITWORD FOLLOW_and_in_andExpr1509_bits[]	= { ANTLR3_UINT64_LIT(0x0800008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_and_in_andExpr1509	= { FOLLOW_and_in_andExpr1509_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_compExpr_in_andExpr1515  */
static	ANTLR3_BITWORD FOLLOW_compExpr_in_andExpr1515_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000002) };
static  ANTLR3_BITSET_LIST FOLLOW_compExpr_in_andExpr1515	= { FOLLOW_compExpr_in_andExpr1515_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addMinExpr_in_compExpr1528  */
static	ANTLR3_BITWORD FOLLOW_addMinExpr_in_compExpr1528_bits[]	= { ANTLR3_UINT64_LIT(0x0003F00000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addMinExpr_in_compExpr1528	= { FOLLOW_addMinExpr_in_compExpr1528_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_comp_in_compExpr1536  */
static	ANTLR3_BITWORD FOLLOW_comp_in_compExpr1536_bits[]	= { ANTLR3_UINT64_LIT(0x0800008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_comp_in_compExpr1536	= { FOLLOW_comp_in_compExpr1536_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addMinExpr_in_compExpr1540  */
static	ANTLR3_BITWORD FOLLOW_addMinExpr_in_compExpr1540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addMinExpr_in_compExpr1540	= { FOLLOW_addMinExpr_in_compExpr1540_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multDivExpr_in_addMinExpr1551  */
static	ANTLR3_BITWORD FOLLOW_multDivExpr_in_addMinExpr1551_bits[]	= { ANTLR3_UINT64_LIT(0x000000A000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multDivExpr_in_addMinExpr1551	= { FOLLOW_multDivExpr_in_addMinExpr1551_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addMin_in_addMinExpr1556  */
static	ANTLR3_BITWORD FOLLOW_addMin_in_addMinExpr1556_bits[]	= { ANTLR3_UINT64_LIT(0x0800008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_addMin_in_addMinExpr1556	= { FOLLOW_addMin_in_addMinExpr1556_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multDivExpr_in_addMinExpr1559  */
static	ANTLR3_BITWORD FOLLOW_multDivExpr_in_addMinExpr1559_bits[]	= { ANTLR3_UINT64_LIT(0x000000A000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_multDivExpr_in_addMinExpr1559	= { FOLLOW_multDivExpr_in_addMinExpr1559_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atom_in_multDivExpr1569  */
static	ANTLR3_BITWORD FOLLOW_atom_in_multDivExpr1569_bits[]	= { ANTLR3_UINT64_LIT(0x0000011000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atom_in_multDivExpr1569	= { FOLLOW_atom_in_multDivExpr1569_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_multDiv_in_multDivExpr1580  */
static	ANTLR3_BITWORD FOLLOW_multDiv_in_multDivExpr1580_bits[]	= { ANTLR3_UINT64_LIT(0x0800008410044000) };
static  ANTLR3_BITSET_LIST FOLLOW_multDiv_in_multDivExpr1580	= { FOLLOW_multDiv_in_multDivExpr1580_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_atom_in_multDivExpr1590  */
static	ANTLR3_BITWORD FOLLOW_atom_in_multDivExpr1590_bits[]	= { ANTLR3_UINT64_LIT(0x0000011000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_atom_in_multDivExpr1590	= { FOLLOW_atom_in_multDivExpr1590_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_33_in_and1648  */
static	ANTLR3_BITWORD FOLLOW_33_in_and1648_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_33_in_and1648	= { FOLLOW_33_in_and1648_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_64_in_or1661  */
static	ANTLR3_BITWORD FOLLOW_64_in_or1661_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_64_in_or1661	= { FOLLOW_64_in_or1661_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_assign1670  */
static	ANTLR3_BITWORD FOLLOW_42_in_assign1670_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_assign1670	= { FOLLOW_42_in_assign1670_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start program
 * ./src/Tiger.g:28:1: program : instructions ;
 */
static TigerParser_program_return
program(pTigerParser ctx)
{
    TigerParser_program_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_instructions_return instructions1;
    #undef	RETURN_TYPE_instructions1
    #define	RETURN_TYPE_instructions1 TigerParser_instructions_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    instructions1.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:28:9: ( instructions )
        // ./src/Tiger.g:28:11: instructions
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_instructions_in_program249);
            instructions1=instructions(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprogramEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, instructions1.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprogramEx; /* Prevent compiler warnings */
    ruleprogramEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end program */

/**
 * $ANTLR start instructions
 * ./src/Tiger.g:30:1: instructions : instruction -> ^( INSTRUCTIONS instruction ) ;
 */
static TigerParser_instructions_return
instructions(pTigerParser ctx)
{
    TigerParser_instructions_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_instruction_return instruction2;
    #undef	RETURN_TYPE_instruction2
    #define	RETURN_TYPE_instruction2 TigerParser_instruction_return

    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_instruction;
    /* Initialize rule variables
     */

    root_0 = NULL;

    instruction2.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;



    stream_instruction   = NULL;
    #define CREATE_stream_instruction  if (stream_instruction == NULL) {stream_instruction = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule instruction"); }

    retval.tree  = NULL;

    {
        // ./src/Tiger.g:31:3: ( instruction -> ^( INSTRUCTIONS instruction ) )
        // ./src/Tiger.g:31:5: instruction
        {
            FOLLOWPUSH(FOLLOW_instruction_in_instructions260);
            instruction2=instruction(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinstructionsEx;
            }

            CREATE_stream_instruction; stream_instruction->add(stream_instruction, instruction2.tree, NULL);

            /* AST REWRITE
             * elements          : instruction
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 31:81: -> ^( INSTRUCTIONS instruction )
            	{
            	    // ./src/Tiger.g:31:84: ^( INSTRUCTIONS instruction )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, INSTRUCTIONS, (pANTLR3_UINT8)"INSTRUCTIONS")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instruction == NULL ? NULL : stream_instruction->nextTree(stream_instruction));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinstructionsEx; /* Prevent compiler warnings */
    ruleinstructionsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_instruction != NULL) stream_instruction->free(stream_instruction);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end instructions */

/**
 * $ANTLR start declaration
 * ./src/Tiger.g:36:1: declaration : ( 'var' name= ID ( ':' type= ID )? ':=' expr -> ^( VAR_DECLARATION $name ( $type)? expr ) | 'function' name= ID params ( ':' return_type= ID )? '=' instructions -> ^( FUNC_DECLARATION $name params ^( TYPE ( $return_type)? ) instructions ) );
 */
static TigerParser_declaration_return
declaration(pTigerParser ctx)
{
    TigerParser_declaration_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    name;
    pANTLR3_COMMON_TOKEN    type;
    pANTLR3_COMMON_TOKEN    return_type;
    pANTLR3_COMMON_TOKEN    string_literal3;
    pANTLR3_COMMON_TOKEN    char_literal4;
    pANTLR3_COMMON_TOKEN    string_literal5;
    pANTLR3_COMMON_TOKEN    string_literal7;
    pANTLR3_COMMON_TOKEN    char_literal9;
    pANTLR3_COMMON_TOKEN    char_literal10;
    TigerParser_expr_return expr6;
    #undef	RETURN_TYPE_expr6
    #define	RETURN_TYPE_expr6 TigerParser_expr_return

    TigerParser_params_return params8;
    #undef	RETURN_TYPE_params8
    #define	RETURN_TYPE_params8 TigerParser_params_return

    TigerParser_instructions_return instructions11;
    #undef	RETURN_TYPE_instructions11
    #define	RETURN_TYPE_instructions11 TigerParser_instructions_return

    pANTLR3_BASE_TREE name_tree;
    pANTLR3_BASE_TREE type_tree;
    pANTLR3_BASE_TREE return_type_tree;
    pANTLR3_BASE_TREE string_literal3_tree;
    pANTLR3_BASE_TREE char_literal4_tree;
    pANTLR3_BASE_TREE string_literal5_tree;
    pANTLR3_BASE_TREE string_literal7_tree;
    pANTLR3_BASE_TREE char_literal9_tree;
    pANTLR3_BASE_TREE char_literal10_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_55;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_47;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_62;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_41;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_42;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_instructions;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_expr;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_params;
    /* Initialize rule variables
     */

    root_0 = NULL;

    name       = NULL;
    type       = NULL;
    return_type       = NULL;
    string_literal3       = NULL;
    char_literal4       = NULL;
    string_literal5       = NULL;
    string_literal7       = NULL;
    char_literal9       = NULL;
    char_literal10       = NULL;
    expr6.tree = NULL;

    params8.tree = NULL;

    instructions11.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    name_tree   = NULL;
    type_tree   = NULL;
    return_type_tree   = NULL;
    string_literal3_tree   = NULL;
    char_literal4_tree   = NULL;
    string_literal5_tree   = NULL;
    string_literal7_tree   = NULL;
    char_literal9_tree   = NULL;
    char_literal10_tree   = NULL;

    stream_55   = NULL;
    #define CREATE_stream_55  if (stream_55 == NULL) {stream_55 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 55"); } 
    stream_47   = NULL;
    #define CREATE_stream_47  if (stream_47 == NULL) {stream_47 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 47"); } 
    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 
    stream_62   = NULL;
    #define CREATE_stream_62  if (stream_62 == NULL) {stream_62 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 62"); } 
    stream_41   = NULL;
    #define CREATE_stream_41  if (stream_41 == NULL) {stream_41 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 41"); } 
    stream_42   = NULL;
    #define CREATE_stream_42  if (stream_42 == NULL) {stream_42 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 42"); } 
    stream_instructions   = NULL;
    #define CREATE_stream_instructions  if (stream_instructions == NULL) {stream_instructions = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule instructions"); }
    stream_expr   = NULL;
    #define CREATE_stream_expr  if (stream_expr == NULL) {stream_expr = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule expr"); }
    stream_params   = NULL;
    #define CREATE_stream_params  if (stream_params == NULL) {stream_params = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule params"); }

    retval.tree  = NULL;

    {
        {
            //  ./src/Tiger.g:37:3: ( 'var' name= ID ( ':' type= ID )? ':=' expr -> ^( VAR_DECLARATION $name ( $type)? expr ) | 'function' name= ID params ( ':' return_type= ID )? '=' instructions -> ^( FUNC_DECLARATION $name params ^( TYPE ( $return_type)? ) instructions ) )

            ANTLR3_UINT32 alt3;

            alt3=2;

            switch ( LA(1) )
            {
            case 62:
            	{
            		alt3=1;
            	}
                break;
            case 55:
            	{
            		alt3=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 3;
                EXCEPTION->state        = 0;


                goto ruledeclarationEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // ./src/Tiger.g:37:5: 'var' name= ID ( ':' type= ID )? ':=' expr
        	    {
        	        string_literal3 = (pANTLR3_COMMON_TOKEN) MATCHT(62, &FOLLOW_62_in_declaration347);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }
        	         
        	        CREATE_stream_62; stream_62->add(stream_62, string_literal3, NULL);


        	        name = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_declaration351);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, name, NULL);


        	        // ./src/Tiger.g:37:19: ( ':' type= ID )?
        	        {
        	            int alt1=2;
        	            switch ( LA(1) )
        	            {
        	                case 41:
        	                	{
        	                		alt1=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt1)
        	            {
        	        	case 1:
        	        	    // ./src/Tiger.g:37:20: ':' type= ID
        	        	    {
        	        	        char_literal4 = (pANTLR3_COMMON_TOKEN) MATCHT(41, &FOLLOW_41_in_declaration354);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclarationEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_41; stream_41->add(stream_41, char_literal4, NULL);


        	        	        type = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_declaration358);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclarationEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_ID; stream_ID->add(stream_ID, type, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        string_literal5 = (pANTLR3_COMMON_TOKEN) MATCHT(42, &FOLLOW_42_in_declaration362);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }
        	         
        	        CREATE_stream_42; stream_42->add(stream_42, string_literal5, NULL);


        	        FOLLOWPUSH(FOLLOW_expr_in_declaration364);
        	        expr6=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }

        	        CREATE_stream_expr; stream_expr->add(stream_expr, expr6.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : type, name, expr
        	         * token labels      : name, type
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_name;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_type;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_name=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token name", name);
        	        	stream_type=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token type", type);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 37:81: -> ^( VAR_DECLARATION $name ( $type)? expr )
        	        	{
        	        	    // ./src/Tiger.g:37:84: ^( VAR_DECLARATION $name ( $type)? expr )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, VAR_DECLARATION, (pANTLR3_UINT8)"VAR_DECLARATION")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_name == NULL ? NULL : stream_name->nextNode(stream_name));

        	        	        // ./src/Tiger.g:37:109: ( $type)?
        	        	        {
        	        	        	if ( (stream_type != NULL && stream_type->hasNext(stream_type))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_type == NULL ? NULL : stream_type->nextNode(stream_type));

        	        	        	}
        	        	        	if ( stream_type != NULL) stream_type->reset(stream_type);

        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_expr == NULL ? NULL : stream_expr->nextTree(stream_expr));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_name != NULL) stream_name->free(stream_name); 
        	        	if (stream_type != NULL) stream_type->free(stream_type); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // ./src/Tiger.g:38:5: 'function' name= ID params ( ':' return_type= ID )? '=' instructions
        	    {
        	        string_literal7 = (pANTLR3_COMMON_TOKEN) MATCHT(55, &FOLLOW_55_in_declaration422);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }
        	         
        	        CREATE_stream_55; stream_55->add(stream_55, string_literal7, NULL);


        	        name = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_declaration426);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, name, NULL);


        	        FOLLOWPUSH(FOLLOW_params_in_declaration428);
        	        params8=params(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }

        	        CREATE_stream_params; stream_params->add(stream_params, params8.tree, NULL);

        	        // ./src/Tiger.g:38:31: ( ':' return_type= ID )?
        	        {
        	            int alt2=2;
        	            switch ( LA(1) )
        	            {
        	                case 41:
        	                	{
        	                		alt2=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt2)
        	            {
        	        	case 1:
        	        	    // ./src/Tiger.g:38:32: ':' return_type= ID
        	        	    {
        	        	        char_literal9 = (pANTLR3_COMMON_TOKEN) MATCHT(41, &FOLLOW_41_in_declaration431);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclarationEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_41; stream_41->add(stream_41, char_literal9, NULL);


        	        	        return_type = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_declaration435);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruledeclarationEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_ID; stream_ID->add(stream_ID, return_type, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        char_literal10 = (pANTLR3_COMMON_TOKEN) MATCHT(47, &FOLLOW_47_in_declaration439);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }
        	         
        	        CREATE_stream_47; stream_47->add(stream_47, char_literal10, NULL);


        	        FOLLOWPUSH(FOLLOW_instructions_in_declaration441);
        	        instructions11=instructions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }

        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, instructions11.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : instructions, params, name, return_type
        	         * token labels      : return_type, name
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_return_type;
        	        	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_name;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_return_type=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token return_type", return_type);
        	        	stream_name=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token name", name);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 38:81: -> ^( FUNC_DECLARATION $name params ^( TYPE ( $return_type)? ) instructions )
        	        	{
        	        	    // ./src/Tiger.g:38:84: ^( FUNC_DECLARATION $name params ^( TYPE ( $return_type)? ) instructions )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FUNC_DECLARATION, (pANTLR3_UINT8)"FUNC_DECLARATION")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_name == NULL ? NULL : stream_name->nextNode(stream_name));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_params == NULL ? NULL : stream_params->nextTree(stream_params));

        	        	        // ./src/Tiger.g:38:116: ^( TYPE ( $return_type)? )
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	            (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TYPE, (pANTLR3_UINT8)"TYPE")
        	        	            , root_2));

        	        	            // ./src/Tiger.g:38:124: ( $return_type)?
        	        	            {
        	        	            	if ( (stream_return_type != NULL && stream_return_type->hasNext(stream_return_type))  )
        	        	            	{
        	        	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_return_type == NULL ? NULL : stream_return_type->nextNode(stream_return_type));

        	        	            	}
        	        	            	if ( stream_return_type != NULL) stream_return_type->reset(stream_return_type);

        	        	            }

        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instructions == NULL ? NULL : stream_instructions->nextTree(stream_instructions));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_return_type != NULL) stream_return_type->free(stream_return_type); 
        	        	if (stream_name != NULL) stream_name->free(stream_name); 
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledeclarationEx; /* Prevent compiler warnings */
    ruledeclarationEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_55 != NULL) stream_55->free(stream_55);
        if (stream_47 != NULL) stream_47->free(stream_47);
        if (stream_ID != NULL) stream_ID->free(stream_ID);
        if (stream_62 != NULL) stream_62->free(stream_62);
        if (stream_41 != NULL) stream_41->free(stream_41);
        if (stream_42 != NULL) stream_42->free(stream_42);
        if (stream_instructions != NULL) stream_instructions->free(stream_instructions);
        if (stream_expr != NULL) stream_expr->free(stream_expr);
        if (stream_params != NULL) stream_params->free(stream_params);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end declaration */

/**
 * $ANTLR start params
 * ./src/Tiger.g:41:1: params : '(' ( param ( ',' param )* )? ')' -> ^( PARAMS ( param )* ) ;
 */
static TigerParser_params_return
params(pTigerParser ctx)
{
    TigerParser_params_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal12;
    pANTLR3_COMMON_TOKEN    char_literal14;
    pANTLR3_COMMON_TOKEN    char_literal16;
    TigerParser_param_return param13;
    #undef	RETURN_TYPE_param13
    #define	RETURN_TYPE_param13 TigerParser_param_return

    TigerParser_param_return param15;
    #undef	RETURN_TYPE_param15
    #define	RETURN_TYPE_param15 TigerParser_param_return

    pANTLR3_BASE_TREE char_literal12_tree;
    pANTLR3_BASE_TREE char_literal14_tree;
    pANTLR3_BASE_TREE char_literal16_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_34;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_35;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_38;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_param;
    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal12       = NULL;
    char_literal14       = NULL;
    char_literal16       = NULL;
    param13.tree = NULL;

    param15.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal12_tree   = NULL;
    char_literal14_tree   = NULL;
    char_literal16_tree   = NULL;

    stream_34   = NULL;
    #define CREATE_stream_34  if (stream_34 == NULL) {stream_34 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 34"); } 
    stream_35   = NULL;
    #define CREATE_stream_35  if (stream_35 == NULL) {stream_35 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 35"); } 
    stream_38   = NULL;
    #define CREATE_stream_38  if (stream_38 == NULL) {stream_38 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 38"); } 
    stream_param   = NULL;
    #define CREATE_stream_param  if (stream_param == NULL) {stream_param = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule param"); }

    retval.tree  = NULL;

    {
        // ./src/Tiger.g:42:3: ( '(' ( param ( ',' param )* )? ')' -> ^( PARAMS ( param )* ) )
        // ./src/Tiger.g:42:5: '(' ( param ( ',' param )* )? ')'
        {
            char_literal12 = (pANTLR3_COMMON_TOKEN) MATCHT(34, &FOLLOW_34_in_params486);
            if  (HASEXCEPTION())
            {
                goto ruleparamsEx;
            }
             
            CREATE_stream_34; stream_34->add(stream_34, char_literal12, NULL);


            // ./src/Tiger.g:42:9: ( param ( ',' param )* )?
            {
                int alt5=2;
                switch ( LA(1) )
                {
                    case ID:
                    	{
                    		alt5=1;
                    	}
                        break;
                }

                switch (alt5)
                {
            	case 1:
            	    // ./src/Tiger.g:42:11: param ( ',' param )*
            	    {
            	        FOLLOWPUSH(FOLLOW_param_in_params490);
            	        param13=param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleparamsEx;
            	        }

            	        CREATE_stream_param; stream_param->add(stream_param, param13.tree, NULL);

            	        // ./src/Tiger.g:42:17: ( ',' param )*

            	        for (;;)
            	        {
            	            int alt4=2;
            	            switch ( LA(1) )
            	            {
            	            case 38:
            	            	{
            	            		alt4=1;
            	            	}
            	                break;

            	            }

            	            switch (alt4)
            	            {
            	        	case 1:
            	        	    // ./src/Tiger.g:42:18: ',' param
            	        	    {
            	        	        char_literal14 = (pANTLR3_COMMON_TOKEN) MATCHT(38, &FOLLOW_38_in_params493);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleparamsEx;
            	        	        }
            	        	         
            	        	        CREATE_stream_38; stream_38->add(stream_38, char_literal14, NULL);


            	        	        FOLLOWPUSH(FOLLOW_param_in_params495);
            	        	        param15=param(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleparamsEx;
            	        	        }

            	        	        CREATE_stream_param; stream_param->add(stream_param, param15.tree, NULL);

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop4;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop4: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            char_literal16 = (pANTLR3_COMMON_TOKEN) MATCHT(35, &FOLLOW_35_in_params501);
            if  (HASEXCEPTION())
            {
                goto ruleparamsEx;
            }
             
            CREATE_stream_35; stream_35->add(stream_35, char_literal16, NULL);


            /* AST REWRITE
             * elements          : param
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 42:81: -> ^( PARAMS ( param )* )
            	{
            	    // ./src/Tiger.g:42:84: ^( PARAMS ( param )* )
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PARAMS, (pANTLR3_UINT8)"PARAMS")
            	        , root_1));

            	        // ./src/Tiger.g:42:93: ( param )*
            	        {
            	        	while ( (stream_param != NULL && stream_param->hasNext(stream_param))  )
            	        	{
            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_param == NULL ? NULL : stream_param->nextTree(stream_param));

            	        	}
            	        	if (stream_param != NULL) stream_param->reset(stream_param);

            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparamsEx; /* Prevent compiler warnings */
    ruleparamsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_34 != NULL) stream_34->free(stream_34);
        if (stream_35 != NULL) stream_35->free(stream_35);
        if (stream_38 != NULL) stream_38->free(stream_38);
        if (stream_param != NULL) stream_param->free(stream_param);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end params */

/**
 * $ANTLR start param
 * ./src/Tiger.g:44:1: param : name= ID ':' type= ID -> ^( PARAM $name $type) ;
 */
static TigerParser_param_return
param(pTigerParser ctx)
{
    TigerParser_param_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    name;
    pANTLR3_COMMON_TOKEN    type;
    pANTLR3_COMMON_TOKEN    char_literal17;

    pANTLR3_BASE_TREE name_tree;
    pANTLR3_BASE_TREE type_tree;
    pANTLR3_BASE_TREE char_literal17_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_41;

    /* Initialize rule variables
     */

    root_0 = NULL;

    name       = NULL;
    type       = NULL;
    char_literal17       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    name_tree   = NULL;
    type_tree   = NULL;
    char_literal17_tree   = NULL;

    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 
    stream_41   = NULL;
    #define CREATE_stream_41  if (stream_41 == NULL) {stream_41 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 41"); } 

    retval.tree  = NULL;

    {
        // ./src/Tiger.g:45:3: (name= ID ':' type= ID -> ^( PARAM $name $type) )
        // ./src/Tiger.g:45:5: name= ID ':' type= ID
        {
            name = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_param569);
            if  (HASEXCEPTION())
            {
                goto ruleparamEx;
            }
             
            CREATE_stream_ID; stream_ID->add(stream_ID, name, NULL);


            char_literal17 = (pANTLR3_COMMON_TOKEN) MATCHT(41, &FOLLOW_41_in_param571);
            if  (HASEXCEPTION())
            {
                goto ruleparamEx;
            }
             
            CREATE_stream_41; stream_41->add(stream_41, char_literal17, NULL);


            type = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_param575);
            if  (HASEXCEPTION())
            {
                goto ruleparamEx;
            }
             
            CREATE_stream_ID; stream_ID->add(stream_ID, type, NULL);


            /* AST REWRITE
             * elements          : type, name
             * token labels      : name, type
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_name;
            	pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_type;
            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

            	stream_name=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token name", name);
            	stream_type=antlr3RewriteRuleTOKENStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token type", type);
            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	retval.tree    = root_0;
            	// 45:81: -> ^( PARAM $name $type)
            	{
            	    // ./src/Tiger.g:45:84: ^( PARAM $name $type)
            	    {
            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
            	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PARAM, (pANTLR3_UINT8)"PARAM")
            	        , root_1));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_name == NULL ? NULL : stream_name->nextNode(stream_name));

            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_type == NULL ? NULL : stream_type->nextNode(stream_type));

            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
            	    }

            	}


            	retval.tree = root_0; // set result root
            	if (stream_name != NULL) stream_name->free(stream_name); 
            	if (stream_type != NULL) stream_type->free(stream_type); 
            	if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto ruleparamEx; /* Prevent compiler warnings */
    ruleparamEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_ID != NULL) stream_ID->free(stream_ID);
        if (stream_41 != NULL) stream_41->free(stream_41);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end param */

/**
 * $ANTLR start instruction
 * ./src/Tiger.g:50:1: instruction : ( 'let' ( declaration )+ 'in' instructions 'end' -> ^( LET ^( DECLARATIONS ( declaration )+ ) instructions ) | expr | 'if' expr 'then' i1= instructions ( options {greedy=true; } : 'else' i2= instructions )? -> ^( IF expr $i1 ( $i2)? ) | 'while' expr 'do' instructions -> ^( WHILE expr instructions ) | 'for' ID ':=' v1= expr 'to' v2= expr 'do' instructions -> ^( FOR ID $v1 $v2 instructions ) | 'break' );
 */
static TigerParser_instruction_return
instruction(pTigerParser ctx)
{
    TigerParser_instruction_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal18;
    pANTLR3_COMMON_TOKEN    string_literal20;
    pANTLR3_COMMON_TOKEN    string_literal22;
    pANTLR3_COMMON_TOKEN    string_literal24;
    pANTLR3_COMMON_TOKEN    string_literal26;
    pANTLR3_COMMON_TOKEN    string_literal27;
    pANTLR3_COMMON_TOKEN    string_literal28;
    pANTLR3_COMMON_TOKEN    string_literal30;
    pANTLR3_COMMON_TOKEN    string_literal32;
    pANTLR3_COMMON_TOKEN    ID33;
    pANTLR3_COMMON_TOKEN    string_literal34;
    pANTLR3_COMMON_TOKEN    string_literal35;
    pANTLR3_COMMON_TOKEN    string_literal36;
    pANTLR3_COMMON_TOKEN    string_literal38;
    TigerParser_instructions_return i1;
    #undef	RETURN_TYPE_i1
    #define	RETURN_TYPE_i1 TigerParser_instructions_return

    TigerParser_instructions_return i2;
    #undef	RETURN_TYPE_i2
    #define	RETURN_TYPE_i2 TigerParser_instructions_return

    TigerParser_expr_return v1;
    #undef	RETURN_TYPE_v1
    #define	RETURN_TYPE_v1 TigerParser_expr_return

    TigerParser_expr_return v2;
    #undef	RETURN_TYPE_v2
    #define	RETURN_TYPE_v2 TigerParser_expr_return

    TigerParser_declaration_return declaration19;
    #undef	RETURN_TYPE_declaration19
    #define	RETURN_TYPE_declaration19 TigerParser_declaration_return

    TigerParser_instructions_return instructions21;
    #undef	RETURN_TYPE_instructions21
    #define	RETURN_TYPE_instructions21 TigerParser_instructions_return

    TigerParser_expr_return expr23;
    #undef	RETURN_TYPE_expr23
    #define	RETURN_TYPE_expr23 TigerParser_expr_return

    TigerParser_expr_return expr25;
    #undef	RETURN_TYPE_expr25
    #define	RETURN_TYPE_expr25 TigerParser_expr_return

    TigerParser_expr_return expr29;
    #undef	RETURN_TYPE_expr29
    #define	RETURN_TYPE_expr29 TigerParser_expr_return

    TigerParser_instructions_return instructions31;
    #undef	RETURN_TYPE_instructions31
    #define	RETURN_TYPE_instructions31 TigerParser_instructions_return

    TigerParser_instructions_return instructions37;
    #undef	RETURN_TYPE_instructions37
    #define	RETURN_TYPE_instructions37 TigerParser_instructions_return

    pANTLR3_BASE_TREE string_literal18_tree;
    pANTLR3_BASE_TREE string_literal20_tree;
    pANTLR3_BASE_TREE string_literal22_tree;
    pANTLR3_BASE_TREE string_literal24_tree;
    pANTLR3_BASE_TREE string_literal26_tree;
    pANTLR3_BASE_TREE string_literal27_tree;
    pANTLR3_BASE_TREE string_literal28_tree;
    pANTLR3_BASE_TREE string_literal30_tree;
    pANTLR3_BASE_TREE string_literal32_tree;
    pANTLR3_BASE_TREE ID33_tree;
    pANTLR3_BASE_TREE string_literal34_tree;
    pANTLR3_BASE_TREE string_literal35_tree;
    pANTLR3_BASE_TREE string_literal36_tree;
    pANTLR3_BASE_TREE string_literal38_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_57;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_58;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_60;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_61;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_51;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_52;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_63;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_53;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_42;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_instructions;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_expr;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_declaration;
    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal18       = NULL;
    string_literal20       = NULL;
    string_literal22       = NULL;
    string_literal24       = NULL;
    string_literal26       = NULL;
    string_literal27       = NULL;
    string_literal28       = NULL;
    string_literal30       = NULL;
    string_literal32       = NULL;
    ID33       = NULL;
    string_literal34       = NULL;
    string_literal35       = NULL;
    string_literal36       = NULL;
    string_literal38       = NULL;
    i1.tree = NULL;

    i2.tree = NULL;

    v1.tree = NULL;

    v2.tree = NULL;

    declaration19.tree = NULL;

    instructions21.tree = NULL;

    expr23.tree = NULL;

    expr25.tree = NULL;

    expr29.tree = NULL;

    instructions31.tree = NULL;

    instructions37.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal18_tree   = NULL;
    string_literal20_tree   = NULL;
    string_literal22_tree   = NULL;
    string_literal24_tree   = NULL;
    string_literal26_tree   = NULL;
    string_literal27_tree   = NULL;
    string_literal28_tree   = NULL;
    string_literal30_tree   = NULL;
    string_literal32_tree   = NULL;
    ID33_tree   = NULL;
    string_literal34_tree   = NULL;
    string_literal35_tree   = NULL;
    string_literal36_tree   = NULL;
    string_literal38_tree   = NULL;

    stream_56   = NULL;
    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 56"); } 
    stream_57   = NULL;
    #define CREATE_stream_57  if (stream_57 == NULL) {stream_57 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 57"); } 
    stream_58   = NULL;
    #define CREATE_stream_58  if (stream_58 == NULL) {stream_58 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 58"); } 
    stream_60   = NULL;
    #define CREATE_stream_60  if (stream_60 == NULL) {stream_60 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 60"); } 
    stream_61   = NULL;
    #define CREATE_stream_61  if (stream_61 == NULL) {stream_61 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 61"); } 
    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 
    stream_51   = NULL;
    #define CREATE_stream_51  if (stream_51 == NULL) {stream_51 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 51"); } 
    stream_52   = NULL;
    #define CREATE_stream_52  if (stream_52 == NULL) {stream_52 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 52"); } 
    stream_63   = NULL;
    #define CREATE_stream_63  if (stream_63 == NULL) {stream_63 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 63"); } 
    stream_53   = NULL;
    #define CREATE_stream_53  if (stream_53 == NULL) {stream_53 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 53"); } 
    stream_42   = NULL;
    #define CREATE_stream_42  if (stream_42 == NULL) {stream_42 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 42"); } 
    stream_54   = NULL;
    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 54"); } 
    stream_instructions   = NULL;
    #define CREATE_stream_instructions  if (stream_instructions == NULL) {stream_instructions = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule instructions"); }
    stream_expr   = NULL;
    #define CREATE_stream_expr  if (stream_expr == NULL) {stream_expr = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule expr"); }
    stream_declaration   = NULL;
    #define CREATE_stream_declaration  if (stream_declaration == NULL) {stream_declaration = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule declaration"); }

    retval.tree  = NULL;

    {
        {
            //  ./src/Tiger.g:51:3: ( 'let' ( declaration )+ 'in' instructions 'end' -> ^( LET ^( DECLARATIONS ( declaration )+ ) instructions ) | expr | 'if' expr 'then' i1= instructions ( options {greedy=true; } : 'else' i2= instructions )? -> ^( IF expr $i1 ( $i2)? ) | 'while' expr 'do' instructions -> ^( WHILE expr instructions ) | 'for' ID ':=' v1= expr 'to' v2= expr 'do' instructions -> ^( FOR ID $v1 $v2 instructions ) | 'break' )

            ANTLR3_UINT32 alt8;

            alt8=6;

            switch ( LA(1) )
            {
            case 58:
            	{
            		alt8=1;
            	}
                break;
            case ID:
            case INTEGER:
            case STRING:
            case 34:
            case 39:
            case 59:
            	{
            		alt8=2;
            	}
                break;
            case 56:
            	{
            		alt8=3;
            	}
                break;
            case 63:
            	{
            		alt8=4;
            	}
                break;
            case 54:
            	{
            		alt8=5;
            	}
                break;
            case 50:
            	{
            		alt8=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 8;
                EXCEPTION->state        = 0;


                goto ruleinstructionEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // ./src/Tiger.g:51:5: 'let' ( declaration )+ 'in' instructions 'end'
        	    {
        	        string_literal18 = (pANTLR3_COMMON_TOKEN) MATCHT(58, &FOLLOW_58_in_instruction658);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_58; stream_58->add(stream_58, string_literal18, NULL);


        	        // ./src/Tiger.g:51:11: ( declaration )+
        	        {
        	            int cnt6=0;

        	            for (;;)
        	            {
        	                int alt6=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case 55:
        	        	case 62:
        	        		{
        	        			alt6=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt6)
        	        	{
        	        	    case 1:
        	        	        // ./src/Tiger.g:51:11: declaration
        	        	        {
        	        	            FOLLOWPUSH(FOLLOW_declaration_in_instruction660);
        	        	            declaration19=declaration(ctx);

        	        	            FOLLOWPOP();
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleinstructionEx;
        	        	            }

        	        	            CREATE_stream_declaration; stream_declaration->add(stream_declaration, declaration19.tree, NULL);

        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt6 >= 1 )
        	        		{
        	        		    goto loop6;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleinstructionEx;
        	        	}
        	        	cnt6++;
        	            }
        	            loop6: ;	/* Jump to here if this rule does not match */
        	        }

        	        string_literal20 = (pANTLR3_COMMON_TOKEN) MATCHT(57, &FOLLOW_57_in_instruction663);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_57; stream_57->add(stream_57, string_literal20, NULL);


        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction665);
        	        instructions21=instructions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, instructions21.tree, NULL);

        	        string_literal22 = (pANTLR3_COMMON_TOKEN) MATCHT(53, &FOLLOW_53_in_instruction667);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_53; stream_53->add(stream_53, string_literal22, NULL);


        	        /* AST REWRITE
        	         * elements          : declaration, instructions
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 51:81: -> ^( LET ^( DECLARATIONS ( declaration )+ ) instructions )
        	        	{
        	        	    // ./src/Tiger.g:51:84: ^( LET ^( DECLARATIONS ( declaration )+ ) instructions )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, LET, (pANTLR3_UINT8)"LET")
        	        	        , root_1));

        	        	        // ./src/Tiger.g:51:90: ^( DECLARATIONS ( declaration )+ )
        	        	        {
        	        	            pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	            root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	            (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, DECLARATIONS, (pANTLR3_UINT8)"DECLARATIONS")
        	        	            , root_2));

        	        	            if ((stream_declaration == NULL || !stream_declaration->hasNext(stream_declaration))  )
        	        	            {
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;
        	        	                EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;
        	        	            }
        	        	            else
        	        	            {
        	        	            	while ( (stream_declaration->hasNext(stream_declaration))  ) {
        	        	            		ADAPTOR->addChild(ADAPTOR, root_2, stream_declaration == NULL ? NULL : stream_declaration->nextTree(stream_declaration));

        	        	            	}
        	        	            	stream_declaration->reset(stream_declaration);

        	        	            }
        	        	            ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instructions == NULL ? NULL : stream_instructions->nextTree(stream_instructions));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // ./src/Tiger.g:53:5: expr
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_expr_in_instruction722);
        	        expr23=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, expr23.tree);

        	    }
        	    break;
        	case 3:
        	    // ./src/Tiger.g:55:5: 'if' expr 'then' i1= instructions ( options {greedy=true; } : 'else' i2= instructions )?
        	    {
        	        string_literal24 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_instruction729);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_56; stream_56->add(stream_56, string_literal24, NULL);


        	        FOLLOWPUSH(FOLLOW_expr_in_instruction731);
        	        expr25=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_expr; stream_expr->add(stream_expr, expr25.tree, NULL);

        	        string_literal26 = (pANTLR3_COMMON_TOKEN) MATCHT(60, &FOLLOW_60_in_instruction733);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_60; stream_60->add(stream_60, string_literal26, NULL);


        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction737);
        	        i1=instructions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, i1.tree, NULL);

        	        // ./src/Tiger.g:56:5: ( options {greedy=true; } : 'else' i2= instructions )?
        	        {
        	            int alt7=2;
        	            switch ( LA(1) )
        	            {
        	                case 52:
        	                	{
        	                		alt7=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt7)
        	            {
        	        	case 1:
        	        	    // ./src/Tiger.g:56:31: 'else' i2= instructions
        	        	    {
        	        	        string_literal27 = (pANTLR3_COMMON_TOKEN) MATCHT(52, &FOLLOW_52_in_instruction753);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleinstructionEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_52; stream_52->add(stream_52, string_literal27, NULL);


        	        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction757);
        	        	        i2=instructions(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleinstructionEx;
        	        	        }

        	        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, i2.tree, NULL);

        	        	    }
        	        	    break;

        	            }
        	        }

        	        /* AST REWRITE
        	         * elements          : i1, expr, i2
        	         * token labels      : 
        	         * rule labels       : i1, i2, retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_i1;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_i2;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_i1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token i1", i1.tree != NULL ? i1.tree : NULL);
        	        	stream_i2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token i2", i2.tree != NULL ? i2.tree : NULL);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 56:81: -> ^( IF expr $i1 ( $i2)? )
        	        	{
        	        	    // ./src/Tiger.g:56:84: ^( IF expr $i1 ( $i2)? )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IF, (pANTLR3_UINT8)"IF")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_expr == NULL ? NULL : stream_expr->nextTree(stream_expr));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_i1 == NULL ? NULL : stream_i1->nextTree(stream_i1));

        	        	        // ./src/Tiger.g:56:99: ( $i2)?
        	        	        {
        	        	        	if ( (stream_i2 != NULL && stream_i2->hasNext(stream_i2))  )
        	        	        	{
        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_i2 == NULL ? NULL : stream_i2->nextTree(stream_i2));

        	        	        	}
        	        	        	if ( stream_i2 != NULL) stream_i2->reset(stream_i2);

        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_i1 != NULL) stream_i1->free(stream_i1);
        	        	if (stream_i2 != NULL) stream_i2->free(stream_i2);
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 4:
        	    // ./src/Tiger.g:57:5: 'while' expr 'do' instructions
        	    {
        	        string_literal28 = (pANTLR3_COMMON_TOKEN) MATCHT(63, &FOLLOW_63_in_instruction805);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_63; stream_63->add(stream_63, string_literal28, NULL);


        	        FOLLOWPUSH(FOLLOW_expr_in_instruction807);
        	        expr29=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_expr; stream_expr->add(stream_expr, expr29.tree, NULL);

        	        string_literal30 = (pANTLR3_COMMON_TOKEN) MATCHT(51, &FOLLOW_51_in_instruction809);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_51; stream_51->add(stream_51, string_literal30, NULL);


        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction811);
        	        instructions31=instructions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, instructions31.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : expr, instructions
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 57:81: -> ^( WHILE expr instructions )
        	        	{
        	        	    // ./src/Tiger.g:57:84: ^( WHILE expr instructions )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WHILE, (pANTLR3_UINT8)"WHILE")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_expr == NULL ? NULL : stream_expr->nextTree(stream_expr));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instructions == NULL ? NULL : stream_instructions->nextTree(stream_instructions));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 5:
        	    // ./src/Tiger.g:58:5: 'for' ID ':=' v1= expr 'to' v2= expr 'do' instructions
        	    {
        	        string_literal32 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_instruction872);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_54; stream_54->add(stream_54, string_literal32, NULL);


        	        ID33 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_instruction874);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, ID33, NULL);


        	        string_literal34 = (pANTLR3_COMMON_TOKEN) MATCHT(42, &FOLLOW_42_in_instruction876);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_42; stream_42->add(stream_42, string_literal34, NULL);


        	        FOLLOWPUSH(FOLLOW_expr_in_instruction880);
        	        v1=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_expr; stream_expr->add(stream_expr, v1.tree, NULL);

        	        string_literal35 = (pANTLR3_COMMON_TOKEN) MATCHT(61, &FOLLOW_61_in_instruction882);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_61; stream_61->add(stream_61, string_literal35, NULL);


        	        FOLLOWPUSH(FOLLOW_expr_in_instruction886);
        	        v2=expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_expr; stream_expr->add(stream_expr, v2.tree, NULL);

        	        string_literal36 = (pANTLR3_COMMON_TOKEN) MATCHT(51, &FOLLOW_51_in_instruction888);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }
        	         
        	        CREATE_stream_51; stream_51->add(stream_51, string_literal36, NULL);


        	        FOLLOWPUSH(FOLLOW_instructions_in_instruction890);
        	        instructions37=instructions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        CREATE_stream_instructions; stream_instructions->add(stream_instructions, instructions37.tree, NULL);

        	        /* AST REWRITE
        	         * elements          : v1, instructions, ID, v2
        	         * token labels      : 
        	         * rule labels       : v1, v2, retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_v1;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_v2;
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_v1=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token v1", v1.tree != NULL ? v1.tree : NULL);
        	        	stream_v2=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token v2", v2.tree != NULL ? v2.tree : NULL);
        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 58:81: -> ^( FOR ID $v1 $v2 instructions )
        	        	{
        	        	    // ./src/Tiger.g:58:84: ^( FOR ID $v1 $v2 instructions )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FOR, (pANTLR3_UINT8)"FOR")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_ID == NULL ? NULL : stream_ID->nextNode(stream_ID)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_v1 == NULL ? NULL : stream_v1->nextTree(stream_v1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_v2 == NULL ? NULL : stream_v2->nextTree(stream_v2));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_instructions == NULL ? NULL : stream_instructions->nextTree(stream_instructions));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_v1 != NULL) stream_v1->free(stream_v1);
        	        	if (stream_v2 != NULL) stream_v2->free(stream_v2);
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 6:
        	    // ./src/Tiger.g:59:5: 'break'
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        string_literal38 = (pANTLR3_COMMON_TOKEN) MATCHT(50, &FOLLOW_50_in_instruction935);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinstructionEx;
        	        }

        	        string_literal38_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal38));
        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal38_tree);


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleinstructionEx; /* Prevent compiler warnings */
    ruleinstructionEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_56 != NULL) stream_56->free(stream_56);
        if (stream_57 != NULL) stream_57->free(stream_57);
        if (stream_58 != NULL) stream_58->free(stream_58);
        if (stream_60 != NULL) stream_60->free(stream_60);
        if (stream_61 != NULL) stream_61->free(stream_61);
        if (stream_ID != NULL) stream_ID->free(stream_ID);
        if (stream_51 != NULL) stream_51->free(stream_51);
        if (stream_52 != NULL) stream_52->free(stream_52);
        if (stream_63 != NULL) stream_63->free(stream_63);
        if (stream_53 != NULL) stream_53->free(stream_53);
        if (stream_42 != NULL) stream_42->free(stream_42);
        if (stream_54 != NULL) stream_54->free(stream_54);
        if (stream_instructions != NULL) stream_instructions->free(stream_instructions);
        if (stream_expr != NULL) stream_expr->free(stream_expr);
        if (stream_declaration != NULL) stream_declaration->free(stream_declaration);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end instruction */

/**
 * $ANTLR start atom
 * ./src/Tiger.g:62:1: atom : ( ID ( '(' ( expr ( ',' expr )* )? ')' )? -> ^( ID ( ^( ARGS ( expr )* ) )? ) | '(' instruction ( ';' instruction )* ')' -> ( instruction )+ | STRING -> ^( STR STRING ) | INTEGER -> ^( INT INTEGER ) | '-' INTEGER -> ^( NEG INTEGER ) | 'nil' -> ^( NIL ) );
 */
static TigerParser_atom_return
atom(pTigerParser ctx)
{
    TigerParser_atom_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ID39;
    pANTLR3_COMMON_TOKEN    char_literal40;
    pANTLR3_COMMON_TOKEN    char_literal42;
    pANTLR3_COMMON_TOKEN    char_literal44;
    pANTLR3_COMMON_TOKEN    char_literal45;
    pANTLR3_COMMON_TOKEN    char_literal47;
    pANTLR3_COMMON_TOKEN    char_literal49;
    pANTLR3_COMMON_TOKEN    STRING50;
    pANTLR3_COMMON_TOKEN    INTEGER51;
    pANTLR3_COMMON_TOKEN    char_literal52;
    pANTLR3_COMMON_TOKEN    INTEGER53;
    pANTLR3_COMMON_TOKEN    string_literal54;
    TigerParser_expr_return expr41;
    #undef	RETURN_TYPE_expr41
    #define	RETURN_TYPE_expr41 TigerParser_expr_return

    TigerParser_expr_return expr43;
    #undef	RETURN_TYPE_expr43
    #define	RETURN_TYPE_expr43 TigerParser_expr_return

    TigerParser_instruction_return instruction46;
    #undef	RETURN_TYPE_instruction46
    #define	RETURN_TYPE_instruction46 TigerParser_instruction_return

    TigerParser_instruction_return instruction48;
    #undef	RETURN_TYPE_instruction48
    #define	RETURN_TYPE_instruction48 TigerParser_instruction_return

    pANTLR3_BASE_TREE ID39_tree;
    pANTLR3_BASE_TREE char_literal40_tree;
    pANTLR3_BASE_TREE char_literal42_tree;
    pANTLR3_BASE_TREE char_literal44_tree;
    pANTLR3_BASE_TREE char_literal45_tree;
    pANTLR3_BASE_TREE char_literal47_tree;
    pANTLR3_BASE_TREE char_literal49_tree;
    pANTLR3_BASE_TREE STRING50_tree;
    pANTLR3_BASE_TREE INTEGER51_tree;
    pANTLR3_BASE_TREE char_literal52_tree;
    pANTLR3_BASE_TREE INTEGER53_tree;
    pANTLR3_BASE_TREE string_literal54_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_34;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_35;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_59;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_38;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_39;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_STRING;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_ID;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_43;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_INTEGER;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_instruction;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_expr;
    /* Initialize rule variables
     */

    root_0 = NULL;

    ID39       = NULL;
    char_literal40       = NULL;
    char_literal42       = NULL;
    char_literal44       = NULL;
    char_literal45       = NULL;
    char_literal47       = NULL;
    char_literal49       = NULL;
    STRING50       = NULL;
    INTEGER51       = NULL;
    char_literal52       = NULL;
    INTEGER53       = NULL;
    string_literal54       = NULL;
    expr41.tree = NULL;

    expr43.tree = NULL;

    instruction46.tree = NULL;

    instruction48.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    ID39_tree   = NULL;
    char_literal40_tree   = NULL;
    char_literal42_tree   = NULL;
    char_literal44_tree   = NULL;
    char_literal45_tree   = NULL;
    char_literal47_tree   = NULL;
    char_literal49_tree   = NULL;
    STRING50_tree   = NULL;
    INTEGER51_tree   = NULL;
    char_literal52_tree   = NULL;
    INTEGER53_tree   = NULL;
    string_literal54_tree   = NULL;

    stream_34   = NULL;
    #define CREATE_stream_34  if (stream_34 == NULL) {stream_34 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 34"); } 
    stream_35   = NULL;
    #define CREATE_stream_35  if (stream_35 == NULL) {stream_35 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 35"); } 
    stream_59   = NULL;
    #define CREATE_stream_59  if (stream_59 == NULL) {stream_59 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 59"); } 
    stream_38   = NULL;
    #define CREATE_stream_38  if (stream_38 == NULL) {stream_38 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 38"); } 
    stream_39   = NULL;
    #define CREATE_stream_39  if (stream_39 == NULL) {stream_39 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 39"); } 
    stream_STRING   = NULL;
    #define CREATE_stream_STRING  if (stream_STRING == NULL) {stream_STRING = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token STRING"); } 
    stream_ID   = NULL;
    #define CREATE_stream_ID  if (stream_ID == NULL) {stream_ID = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token ID"); } 
    stream_43   = NULL;
    #define CREATE_stream_43  if (stream_43 == NULL) {stream_43 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token 43"); } 
    stream_INTEGER   = NULL;
    #define CREATE_stream_INTEGER  if (stream_INTEGER == NULL) {stream_INTEGER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token INTEGER"); } 
    stream_instruction   = NULL;
    #define CREATE_stream_instruction  if (stream_instruction == NULL) {stream_instruction = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule instruction"); }
    stream_expr   = NULL;
    #define CREATE_stream_expr  if (stream_expr == NULL) {stream_expr = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule expr"); }

    retval.tree  = NULL;

    {
        {
            //  ./src/Tiger.g:63:3: ( ID ( '(' ( expr ( ',' expr )* )? ')' )? -> ^( ID ( ^( ARGS ( expr )* ) )? ) | '(' instruction ( ';' instruction )* ')' -> ( instruction )+ | STRING -> ^( STR STRING ) | INTEGER -> ^( INT INTEGER ) | '-' INTEGER -> ^( NEG INTEGER ) | 'nil' -> ^( NIL ) )

            ANTLR3_UINT32 alt13;

            alt13=6;

            switch ( LA(1) )
            {
            case ID:
            	{
            		alt13=1;
            	}
                break;
            case 34:
            	{
            		alt13=2;
            	}
                break;
            case STRING:
            	{
            		alt13=3;
            	}
                break;
            case INTEGER:
            	{
            		alt13=4;
            	}
                break;
            case 39:
            	{
            		alt13=5;
            	}
                break;
            case 59:
            	{
            		alt13=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 13;
                EXCEPTION->state        = 0;


                goto ruleatomEx;

            }

            switch (alt13)
            {
        	case 1:
        	    // ./src/Tiger.g:63:5: ID ( '(' ( expr ( ',' expr )* )? ')' )?
        	    {
        	        ID39 = (pANTLR3_COMMON_TOKEN) MATCHT(ID, &FOLLOW_ID_in_atom948);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_ID; stream_ID->add(stream_ID, ID39, NULL);


        	        // ./src/Tiger.g:63:8: ( '(' ( expr ( ',' expr )* )? ')' )?
        	        {
        	            int alt11=2;
        	            switch ( LA(1) )
        	            {
        	                case 34:
        	                	{
        	                		alt11=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt11)
        	            {
        	        	case 1:
        	        	    // ./src/Tiger.g:63:9: '(' ( expr ( ',' expr )* )? ')'
        	        	    {
        	        	        char_literal40 = (pANTLR3_COMMON_TOKEN) MATCHT(34, &FOLLOW_34_in_atom951);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_34; stream_34->add(stream_34, char_literal40, NULL);


        	        	        // ./src/Tiger.g:63:13: ( expr ( ',' expr )* )?
        	        	        {
        	        	            int alt10=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	                case ID:
        	        	                case INTEGER:
        	        	                case STRING:
        	        	                case 34:
        	        	                case 39:
        	        	                case 59:
        	        	                	{
        	        	                		alt10=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt10)
        	        	            {
        	        	        	case 1:
        	        	        	    // ./src/Tiger.g:63:14: expr ( ',' expr )*
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_expr_in_atom954);
        	        	        	        expr41=expr(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleatomEx;
        	        	        	        }

        	        	        	        CREATE_stream_expr; stream_expr->add(stream_expr, expr41.tree, NULL);

        	        	        	        // ./src/Tiger.g:63:19: ( ',' expr )*

        	        	        	        for (;;)
        	        	        	        {
        	        	        	            int alt9=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	            case 38:
        	        	        	            	{
        	        	        	            		alt9=1;
        	        	        	            	}
        	        	        	                break;

        	        	        	            }

        	        	        	            switch (alt9)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // ./src/Tiger.g:63:20: ',' expr
        	        	        	        	    {
        	        	        	        	        char_literal42 = (pANTLR3_COMMON_TOKEN) MATCHT(38, &FOLLOW_38_in_atom957);
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleatomEx;
        	        	        	        	        }
        	        	        	        	         
        	        	        	        	        CREATE_stream_38; stream_38->add(stream_38, char_literal42, NULL);


        	        	        	        	        FOLLOWPUSH(FOLLOW_expr_in_atom959);
        	        	        	        	        expr43=expr(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleatomEx;
        	        	        	        	        }

        	        	        	        	        CREATE_stream_expr; stream_expr->add(stream_expr, expr43.tree, NULL);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	        	default:
        	        	        	        	    goto loop9;	/* break out of the loop */
        	        	        	        	    break;
        	        	        	            }
        	        	        	        }
        	        	        	        loop9: ; /* Jump out to here if this rule does not match */


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        char_literal44 = (pANTLR3_COMMON_TOKEN) MATCHT(35, &FOLLOW_35_in_atom965);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_35; stream_35->add(stream_35, char_literal44, NULL);


        	        	    }
        	        	    break;

        	            }
        	        }

        	        /* AST REWRITE
        	         * elements          : expr, ID
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 63:81: -> ^( ID ( ^( ARGS ( expr )* ) )? )
        	        	{
        	        	    // ./src/Tiger.g:63:84: ^( ID ( ^( ARGS ( expr )* ) )? )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        stream_ID == NULL ? NULL : stream_ID->nextNode(stream_ID)
        	        	        , root_1));

        	        	        // ./src/Tiger.g:63:89: ( ^( ARGS ( expr )* ) )?
        	        	        {
        	        	        	if ( (stream_expr != NULL && stream_expr->hasNext(stream_expr))  )
        	        	        	{
        	        	        		// ./src/Tiger.g:63:89: ^( ARGS ( expr )* )
        	        	        		{
        	        	        		    pANTLR3_BASE_TREE root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        		    root_2 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        		    (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ARGS, (pANTLR3_UINT8)"ARGS")
        	        	        		    , root_2));

        	        	        		    // ./src/Tiger.g:63:96: ( expr )*
        	        	        		    {
        	        	        		    	while ( (stream_expr != NULL && stream_expr->hasNext(stream_expr))  )
        	        	        		    	{
        	        	        		    		ADAPTOR->addChild(ADAPTOR, root_2, stream_expr == NULL ? NULL : stream_expr->nextTree(stream_expr));

        	        	        		    	}
        	        	        		    	if (stream_expr != NULL) stream_expr->reset(stream_expr);

        	        	        		    }

        	        	        		    ADAPTOR->addChild(ADAPTOR, root_1, root_2);
        	        	        		}

        	        	        	}
        	        	        	if ( stream_expr != NULL) stream_expr->reset(stream_expr);

        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // ./src/Tiger.g:65:5: '(' instruction ( ';' instruction )* ')'
        	    {
        	        char_literal45 = (pANTLR3_COMMON_TOKEN) MATCHT(34, &FOLLOW_34_in_atom1030);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_34; stream_34->add(stream_34, char_literal45, NULL);


        	        FOLLOWPUSH(FOLLOW_instruction_in_atom1032);
        	        instruction46=instruction(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }

        	        CREATE_stream_instruction; stream_instruction->add(stream_instruction, instruction46.tree, NULL);

        	        // ./src/Tiger.g:65:21: ( ';' instruction )*

        	        for (;;)
        	        {
        	            int alt12=2;
        	            switch ( LA(1) )
        	            {
        	            case 43:
        	            	{
        	            		alt12=1;
        	            	}
        	                break;

        	            }

        	            switch (alt12)
        	            {
        	        	case 1:
        	        	    // ./src/Tiger.g:65:22: ';' instruction
        	        	    {
        	        	        char_literal47 = (pANTLR3_COMMON_TOKEN) MATCHT(43, &FOLLOW_43_in_atom1035);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }
        	        	         
        	        	        CREATE_stream_43; stream_43->add(stream_43, char_literal47, NULL);


        	        	        FOLLOWPUSH(FOLLOW_instruction_in_atom1037);
        	        	        instruction48=instruction(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleatomEx;
        	        	        }

        	        	        CREATE_stream_instruction; stream_instruction->add(stream_instruction, instruction48.tree, NULL);

        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop12;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop12: ; /* Jump out to here if this rule does not match */


        	        char_literal49 = (pANTLR3_COMMON_TOKEN) MATCHT(35, &FOLLOW_35_in_atom1041);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_35; stream_35->add(stream_35, char_literal49, NULL);


        	        /* AST REWRITE
        	         * elements          : instruction
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 65:81: -> ( instruction )+
        	        	{
        	        	    if ((stream_instruction == NULL || !stream_instruction->hasNext(stream_instruction))  )
        	        	    {
        	        	        CONSTRUCTEX();
        	        	        EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;
        	        	        EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;
        	        	    }
        	        	    else
        	        	    {
        	        	    	while ( (stream_instruction->hasNext(stream_instruction))  ) {
        	        	    		ADAPTOR->addChild(ADAPTOR, root_0, stream_instruction == NULL ? NULL : stream_instruction->nextTree(stream_instruction));

        	        	    	}
        	        	    	stream_instruction->reset(stream_instruction);

        	        	    }
        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 3:
        	    // ./src/Tiger.g:67:5: STRING
        	    {
        	        STRING50 = (pANTLR3_COMMON_TOKEN) MATCHT(STRING, &FOLLOW_STRING_in_atom1090);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_STRING; stream_STRING->add(stream_STRING, STRING50, NULL);


        	        /* AST REWRITE
        	         * elements          : STRING
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 67:81: -> ^( STR STRING )
        	        	{
        	        	    // ./src/Tiger.g:67:84: ^( STR STRING )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, STR, (pANTLR3_UINT8)"STR")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_STRING == NULL ? NULL : stream_STRING->nextNode(stream_STRING)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 4:
        	    // ./src/Tiger.g:68:5: INTEGER
        	    {
        	        INTEGER51 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER, &FOLLOW_INTEGER_in_atom1173);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_INTEGER; stream_INTEGER->add(stream_INTEGER, INTEGER51, NULL);


        	        /* AST REWRITE
        	         * elements          : INTEGER
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 68:81: -> ^( INT INTEGER )
        	        	{
        	        	    // ./src/Tiger.g:68:84: ^( INT INTEGER )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, INT, (pANTLR3_UINT8)"INT")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_INTEGER == NULL ? NULL : stream_INTEGER->nextNode(stream_INTEGER)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 5:
        	    // ./src/Tiger.g:69:5: '-' INTEGER
        	    {
        	        char_literal52 = (pANTLR3_COMMON_TOKEN) MATCHT(39, &FOLLOW_39_in_atom1255);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_39; stream_39->add(stream_39, char_literal52, NULL);


        	        INTEGER53 = (pANTLR3_COMMON_TOKEN) MATCHT(INTEGER, &FOLLOW_INTEGER_in_atom1257);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_INTEGER; stream_INTEGER->add(stream_INTEGER, INTEGER53, NULL);


        	        /* AST REWRITE
        	         * elements          : INTEGER
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 69:81: -> ^( NEG INTEGER )
        	        	{
        	        	    // ./src/Tiger.g:69:84: ^( NEG INTEGER )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NEG, (pANTLR3_UINT8)"NEG")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_1, 
        	        	        stream_INTEGER == NULL ? NULL : stream_INTEGER->nextNode(stream_INTEGER)
        	        	        );

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 6:
        	    // ./src/Tiger.g:70:5: 'nil'
        	    {
        	        string_literal54 = (pANTLR3_COMMON_TOKEN) MATCHT(59, &FOLLOW_59_in_atom1335);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleatomEx;
        	        }
        	         
        	        CREATE_stream_59; stream_59->add(stream_59, string_literal54, NULL);


        	        /* AST REWRITE
        	         * elements          : 
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 70:81: -> ^( NIL )
        	        	{
        	        	    // ./src/Tiger.g:70:84: ^( NIL )
        	        	    {
        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
        	        	        (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NIL, (pANTLR3_UINT8)"NIL")
        	        	        , root_1));

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);
        	        	    }

        	        	}


        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleatomEx; /* Prevent compiler warnings */
    ruleatomEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_34 != NULL) stream_34->free(stream_34);
        if (stream_35 != NULL) stream_35->free(stream_35);
        if (stream_59 != NULL) stream_59->free(stream_59);
        if (stream_38 != NULL) stream_38->free(stream_38);
        if (stream_39 != NULL) stream_39->free(stream_39);
        if (stream_STRING != NULL) stream_STRING->free(stream_STRING);
        if (stream_ID != NULL) stream_ID->free(stream_ID);
        if (stream_43 != NULL) stream_43->free(stream_43);
        if (stream_INTEGER != NULL) stream_INTEGER->free(stream_INTEGER);
        if (stream_instruction != NULL) stream_instruction->free(stream_instruction);
        if (stream_expr != NULL) stream_expr->free(stream_expr);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end atom */

/**
 * $ANTLR start expr
 * ./src/Tiger.g:75:1: expr : assignExpr ;
 */
static TigerParser_expr_return
expr(pTigerParser ctx)
{
    TigerParser_expr_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_assignExpr_return assignExpr55;
    #undef	RETURN_TYPE_assignExpr55
    #define	RETURN_TYPE_assignExpr55 TigerParser_assignExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    assignExpr55.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:75:6: ( assignExpr )
        // ./src/Tiger.g:75:8: assignExpr
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_assignExpr_in_expr1424);
            assignExpr55=assignExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, assignExpr55.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleexprEx; /* Prevent compiler warnings */
    ruleexprEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end expr */

/**
 * $ANTLR start assignExpr
 * ./src/Tiger.g:77:1: assignExpr : logExpr ( assign ^ logExpr )* ;
 */
static TigerParser_assignExpr_return
assignExpr(pTigerParser ctx)
{
    TigerParser_assignExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_logExpr_return logExpr56;
    #undef	RETURN_TYPE_logExpr56
    #define	RETURN_TYPE_logExpr56 TigerParser_logExpr_return

    TigerParser_assign_return assign57;
    #undef	RETURN_TYPE_assign57
    #define	RETURN_TYPE_assign57 TigerParser_assign_return

    TigerParser_logExpr_return logExpr58;
    #undef	RETURN_TYPE_logExpr58
    #define	RETURN_TYPE_logExpr58 TigerParser_logExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    logExpr56.tree = NULL;

    assign57.tree = NULL;

    logExpr58.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:77:13: ( logExpr ( assign ^ logExpr )* )
        // ./src/Tiger.g:77:15: logExpr ( assign ^ logExpr )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_logExpr_in_assignExpr1434);
            logExpr56=logExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleassignExprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, logExpr56.tree);

            // ./src/Tiger.g:77:27: ( assign ^ logExpr )*

            for (;;)
            {
                int alt14=2;
                switch ( LA(1) )
                {
                case 42:
                	{
                		alt14=1;
                	}
                    break;

                }

                switch (alt14)
                {
            	case 1:
            	    // ./src/Tiger.g:77:30: assign ^ logExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_assign_in_assignExpr1443);
            	        assign57=assign(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleassignExprEx;
            	        }

            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, assign57.tree, root_0));

            	        FOLLOWPUSH(FOLLOW_logExpr_in_assignExpr1450);
            	        logExpr58=logExpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleassignExprEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, logExpr58.tree);

            	    }
            	    break;

            	default:
            	    goto loop14;	/* break out of the loop */
            	    break;
                }
            }
            loop14: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleassignExprEx; /* Prevent compiler warnings */
    ruleassignExprEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end assignExpr */

/**
 * $ANTLR start logExpr
 * ./src/Tiger.g:78:1: logExpr : andExpr ( or ^ andExpr )* ;
 */
static TigerParser_logExpr_return
logExpr(pTigerParser ctx)
{
    TigerParser_logExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_andExpr_return andExpr59;
    #undef	RETURN_TYPE_andExpr59
    #define	RETURN_TYPE_andExpr59 TigerParser_andExpr_return

    TigerParser_or_return or60;
    #undef	RETURN_TYPE_or60
    #define	RETURN_TYPE_or60 TigerParser_or_return

    TigerParser_andExpr_return andExpr61;
    #undef	RETURN_TYPE_andExpr61
    #define	RETURN_TYPE_andExpr61 TigerParser_andExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    andExpr59.tree = NULL;

    or60.tree = NULL;

    andExpr61.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:78:13: ( andExpr ( or ^ andExpr )* )
        // ./src/Tiger.g:78:15: andExpr ( or ^ andExpr )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_andExpr_in_logExpr1464);
            andExpr59=andExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelogExprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, andExpr59.tree);

            // ./src/Tiger.g:78:27: ( or ^ andExpr )*

            for (;;)
            {
                int alt15=2;
                switch ( LA(1) )
                {
                case 64:
                	{
                		alt15=1;
                	}
                    break;

                }

                switch (alt15)
                {
            	case 1:
            	    // ./src/Tiger.g:78:34: or ^ andExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_or_in_logExpr1477);
            	        or60=or(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelogExprEx;
            	        }

            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, or60.tree, root_0));

            	        FOLLOWPUSH(FOLLOW_andExpr_in_logExpr1484);
            	        andExpr61=andExpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelogExprEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, andExpr61.tree);

            	    }
            	    break;

            	default:
            	    goto loop15;	/* break out of the loop */
            	    break;
                }
            }
            loop15: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulelogExprEx; /* Prevent compiler warnings */
    rulelogExprEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end logExpr */

/**
 * $ANTLR start andExpr
 * ./src/Tiger.g:79:1: andExpr : compExpr ( and ^ compExpr )* ;
 */
static TigerParser_andExpr_return
andExpr(pTigerParser ctx)
{
    TigerParser_andExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_compExpr_return compExpr62;
    #undef	RETURN_TYPE_compExpr62
    #define	RETURN_TYPE_compExpr62 TigerParser_compExpr_return

    TigerParser_and_return and63;
    #undef	RETURN_TYPE_and63
    #define	RETURN_TYPE_and63 TigerParser_and_return

    TigerParser_compExpr_return compExpr64;
    #undef	RETURN_TYPE_compExpr64
    #define	RETURN_TYPE_compExpr64 TigerParser_compExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    compExpr62.tree = NULL;

    and63.tree = NULL;

    compExpr64.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:79:13: ( compExpr ( and ^ compExpr )* )
        // ./src/Tiger.g:79:15: compExpr ( and ^ compExpr )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_compExpr_in_andExpr1498);
            compExpr62=compExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleandExprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, compExpr62.tree);

            // ./src/Tiger.g:79:27: ( and ^ compExpr )*

            for (;;)
            {
                int alt16=2;
                switch ( LA(1) )
                {
                case 33:
                	{
                		alt16=1;
                	}
                    break;

                }

                switch (alt16)
                {
            	case 1:
            	    // ./src/Tiger.g:79:33: and ^ compExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_and_in_andExpr1509);
            	        and63=and(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleandExprEx;
            	        }

            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, and63.tree, root_0));

            	        FOLLOWPUSH(FOLLOW_compExpr_in_andExpr1515);
            	        compExpr64=compExpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleandExprEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, compExpr64.tree);

            	    }
            	    break;

            	default:
            	    goto loop16;	/* break out of the loop */
            	    break;
                }
            }
            loop16: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleandExprEx; /* Prevent compiler warnings */
    ruleandExprEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end andExpr */

/**
 * $ANTLR start compExpr
 * ./src/Tiger.g:80:1: compExpr : addMinExpr ( comp ^ addMinExpr )? ;
 */
static TigerParser_compExpr_return
compExpr(pTigerParser ctx)
{
    TigerParser_compExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_addMinExpr_return addMinExpr65;
    #undef	RETURN_TYPE_addMinExpr65
    #define	RETURN_TYPE_addMinExpr65 TigerParser_addMinExpr_return

    TigerParser_comp_return comp66;
    #undef	RETURN_TYPE_comp66
    #define	RETURN_TYPE_comp66 TigerParser_comp_return

    TigerParser_addMinExpr_return addMinExpr67;
    #undef	RETURN_TYPE_addMinExpr67
    #define	RETURN_TYPE_addMinExpr67 TigerParser_addMinExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    addMinExpr65.tree = NULL;

    comp66.tree = NULL;

    addMinExpr67.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:80:13: ( addMinExpr ( comp ^ addMinExpr )? )
        // ./src/Tiger.g:80:15: addMinExpr ( comp ^ addMinExpr )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_addMinExpr_in_compExpr1528);
            addMinExpr65=addMinExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecompExprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, addMinExpr65.tree);

            // ./src/Tiger.g:80:27: ( comp ^ addMinExpr )?
            {
                int alt17=2;
                switch ( LA(1) )
                {
                    case 44:
                    case 45:
                    case 46:
                    case 47:
                    case 48:
                    case 49:
                    	{
                    		alt17=1;
                    	}
                        break;
                }

                switch (alt17)
                {
            	case 1:
            	    // ./src/Tiger.g:80:32: comp ^ addMinExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_comp_in_compExpr1536);
            	        comp66=comp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecompExprEx;
            	        }

            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, comp66.tree, root_0));

            	        FOLLOWPUSH(FOLLOW_addMinExpr_in_compExpr1540);
            	        addMinExpr67=addMinExpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecompExprEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, addMinExpr67.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulecompExprEx; /* Prevent compiler warnings */
    rulecompExprEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end compExpr */

/**
 * $ANTLR start addMinExpr
 * ./src/Tiger.g:81:1: addMinExpr : multDivExpr ( addMin ^ multDivExpr )* ;
 */
static TigerParser_addMinExpr_return
addMinExpr(pTigerParser ctx)
{
    TigerParser_addMinExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_multDivExpr_return multDivExpr68;
    #undef	RETURN_TYPE_multDivExpr68
    #define	RETURN_TYPE_multDivExpr68 TigerParser_multDivExpr_return

    TigerParser_addMin_return addMin69;
    #undef	RETURN_TYPE_addMin69
    #define	RETURN_TYPE_addMin69 TigerParser_addMin_return

    TigerParser_multDivExpr_return multDivExpr70;
    #undef	RETURN_TYPE_multDivExpr70
    #define	RETURN_TYPE_multDivExpr70 TigerParser_multDivExpr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    multDivExpr68.tree = NULL;

    addMin69.tree = NULL;

    multDivExpr70.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:81:13: ( multDivExpr ( addMin ^ multDivExpr )* )
        // ./src/Tiger.g:81:15: multDivExpr ( addMin ^ multDivExpr )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_multDivExpr_in_addMinExpr1551);
            multDivExpr68=multDivExpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaddMinExprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, multDivExpr68.tree);

            // ./src/Tiger.g:81:27: ( addMin ^ multDivExpr )*

            for (;;)
            {
                int alt18=2;
                switch ( LA(1) )
                {
                case 37:
                case 39:
                	{
                		alt18=1;
                	}
                    break;

                }

                switch (alt18)
                {
            	case 1:
            	    // ./src/Tiger.g:81:30: addMin ^ multDivExpr
            	    {
            	        FOLLOWPUSH(FOLLOW_addMin_in_addMinExpr1556);
            	        addMin69=addMin(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaddMinExprEx;
            	        }

            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, addMin69.tree, root_0));

            	        FOLLOWPUSH(FOLLOW_multDivExpr_in_addMinExpr1559);
            	        multDivExpr70=multDivExpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaddMinExprEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, multDivExpr70.tree);

            	    }
            	    break;

            	default:
            	    goto loop18;	/* break out of the loop */
            	    break;
                }
            }
            loop18: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleaddMinExprEx; /* Prevent compiler warnings */
    ruleaddMinExprEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end addMinExpr */

/**
 * $ANTLR start multDivExpr
 * ./src/Tiger.g:82:1: multDivExpr : atom ( multDiv ^ atom )* ;
 */
static TigerParser_multDivExpr_return
multDivExpr(pTigerParser ctx)
{
    TigerParser_multDivExpr_return retval;


    pANTLR3_BASE_TREE root_0;

    TigerParser_atom_return atom71;
    #undef	RETURN_TYPE_atom71
    #define	RETURN_TYPE_atom71 TigerParser_atom_return

    TigerParser_multDiv_return multDiv72;
    #undef	RETURN_TYPE_multDiv72
    #define	RETURN_TYPE_multDiv72 TigerParser_multDiv_return

    TigerParser_atom_return atom73;
    #undef	RETURN_TYPE_atom73
    #define	RETURN_TYPE_atom73 TigerParser_atom_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    atom71.tree = NULL;

    multDiv72.tree = NULL;

    atom73.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // ./src/Tiger.g:82:13: ( atom ( multDiv ^ atom )* )
        // ./src/Tiger.g:82:15: atom ( multDiv ^ atom )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_atom_in_multDivExpr1569);
            atom71=atom(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemultDivExprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, atom71.tree);

            // ./src/Tiger.g:82:27: ( multDiv ^ atom )*

            for (;;)
            {
                int alt19=2;
                switch ( LA(1) )
                {
                case 36:
                case 40:
                	{
                		alt19=1;
                	}
                    break;

                }

                switch (alt19)
                {
            	case 1:
            	    // ./src/Tiger.g:82:29: multDiv ^ atom
            	    {
            	        FOLLOWPUSH(FOLLOW_multDiv_in_multDivExpr1580);
            	        multDiv72=multDiv(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemultDivExprEx;
            	        }

            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, multDiv72.tree, root_0));

            	        FOLLOWPUSH(FOLLOW_atom_in_multDivExpr1590);
            	        atom73=atom(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemultDivExprEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, atom73.tree);

            	    }
            	    break;

            	default:
            	    goto loop19;	/* break out of the loop */
            	    break;
                }
            }
            loop19: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemultDivExprEx; /* Prevent compiler warnings */
    rulemultDivExprEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end multDivExpr */

/**
 * $ANTLR start addMin
 * ./src/Tiger.g:85:2: addMin : ( '+' | '-' );
 */
static TigerParser_addMin_return
addMin(pTigerParser ctx)
{
    TigerParser_addMin_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set74;

    pANTLR3_BASE_TREE set74_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set74       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set74_tree   = NULL;


    retval.tree  = NULL;

    {
        // ./src/Tiger.g:85:9: ( '+' | '-' )
        // ./src/Tiger.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set74=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == 37 || LA(1) == 39 )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set74))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto ruleaddMinEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleaddMinEx; /* Prevent compiler warnings */
    ruleaddMinEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end addMin */

/**
 * $ANTLR start multDiv
 * ./src/Tiger.g:86:1: multDiv : ( '*' | '/' );
 */
static TigerParser_multDiv_return
multDiv(pTigerParser ctx)
{
    TigerParser_multDiv_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set75;

    pANTLR3_BASE_TREE set75_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set75       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set75_tree   = NULL;


    retval.tree  = NULL;

    {
        // ./src/Tiger.g:86:9: ( '*' | '/' )
        // ./src/Tiger.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set75=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == 36 || LA(1) == 40 )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set75))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulemultDivEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemultDivEx; /* Prevent compiler warnings */
    rulemultDivEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end multDiv */

/**
 * $ANTLR start comp
 * ./src/Tiger.g:87:4: comp : ( '<' | '>' | '<=' | '>=' | '=' | '<>' );
 */
static TigerParser_comp_return
comp(pTigerParser ctx)
{
    TigerParser_comp_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set76;

    pANTLR3_BASE_TREE set76_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set76       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set76_tree   = NULL;


    retval.tree  = NULL;

    {
        // ./src/Tiger.g:87:9: ( '<' | '>' | '<=' | '>=' | '=' | '<>' )
        // ./src/Tiger.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set76=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( ((LA(1) >= 44) && (LA(1) <= 49)) )
            {
                CONSUME();
                ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set76))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulecompEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecompEx; /* Prevent compiler warnings */
    rulecompEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end comp */

/**
 * $ANTLR start and
 * ./src/Tiger.g:88:5: and : '&' ;
 */
static TigerParser_and_return
and(pTigerParser ctx)
{
    TigerParser_and_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal77;

    pANTLR3_BASE_TREE char_literal77_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal77       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal77_tree   = NULL;


    retval.tree  = NULL;

    {
        // ./src/Tiger.g:88:9: ( '&' )
        // ./src/Tiger.g:88:11: '&'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            char_literal77 = (pANTLR3_COMMON_TOKEN) MATCHT(33, &FOLLOW_33_in_and1648);
            if  (HASEXCEPTION())
            {
                goto ruleandEx;
            }

            char_literal77_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal77));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal77_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleandEx; /* Prevent compiler warnings */
    ruleandEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end and */

/**
 * $ANTLR start or
 * ./src/Tiger.g:89:5: or : '|' ;
 */
static TigerParser_or_return
or(pTigerParser ctx)
{
    TigerParser_or_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal78;

    pANTLR3_BASE_TREE char_literal78_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal78       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal78_tree   = NULL;


    retval.tree  = NULL;

    {
        // ./src/Tiger.g:89:9: ( '|' )
        // ./src/Tiger.g:89:11: '|'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            char_literal78 = (pANTLR3_COMMON_TOKEN) MATCHT(64, &FOLLOW_64_in_or1661);
            if  (HASEXCEPTION())
            {
                goto ruleorEx;
            }

            char_literal78_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal78));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal78_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleorEx; /* Prevent compiler warnings */
    ruleorEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end or */

/**
 * $ANTLR start assign
 * ./src/Tiger.g:90:1: assign : ':=' ;
 */
static TigerParser_assign_return
assign(pTigerParser ctx)
{
    TigerParser_assign_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal79;

    pANTLR3_BASE_TREE string_literal79_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal79       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal79_tree   = NULL;


    retval.tree  = NULL;

    {
        // ./src/Tiger.g:90:9: ( ':=' )
        // ./src/Tiger.g:90:11: ':='
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal79 = (pANTLR3_COMMON_TOKEN) MATCHT(42, &FOLLOW_42_in_assign1670);
            if  (HASEXCEPTION())
            {
                goto ruleassignEx;
            }

            string_literal79_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal79));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal79_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleassignEx; /* Prevent compiler warnings */
    ruleassignEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end assign */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
